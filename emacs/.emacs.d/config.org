#+title: Emacs configuration file
#+property: header-args:emacs-lisp :tangle yes

* Visual Appearance
  Adjust the visual things at the beginning, this prevents ugly
  changes during the startup if other parts need more time to execute.
  This leads to an impression of a fast loading init file.

  Load a color theme:
  #+begin_src emacs-lisp
    (load-theme 'tango-dark-new t)		;don't confirm the load
  #+end_src
  
  Remove the tool bar and the scroll bar, but only in graphical mode.
  In terminal mode this would result in errors or warnings.  In order
  to make this distinction, carry out the customizations when making a
  new, graphical frame.  This also works in server-mode if it is
  called as ~emacsclient~, or ~emacsclient -c~.
  #+begin_src emacs-lisp
    (defun new-frame-setup (frame)
      (when (display-graphic-p frame)
	(progn
	  (tool-bar-mode -1)
	  (scroll-bar-mode -1))))
    (add-hook 'after-make-frame-functions 'new-frame-setup)
  #+end_src
  
  Allow Emacs to resize pixel-wise, not in full multiples of character
  width or height. This comes handy, when your window manager
  leaves a small stripe of unused space next to Emacs frames
  (window manager windows).
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq frame-resize-pixelwise t)
  #+END_SRC
  
  Some unnecessary visual parts should always be removed.  Also add
  some useful information to the mode line.
  #+begin_src emacs-lisp
    (menu-bar-mode -1)
    (blink-cursor-mode -1)
    (column-number-mode)
    (display-time-mode t)
  #+end_src
  
  Remove the start message
  #+begin_src emacs-lisp
    (setq inhibit-startup-screen t)
  #+end_src
  
* General Settings  
** Emacs Server
  Start Emacs server for being able to use emacsclient do not start it
  when already running, this is particularly useful if you edit the
  Emacs configuration and use eval-buffer for testing the effects.
  Note: it is not so easy to check whether the server is running or
  not, it just seems so. You may be surprised by the behavior!
  #+begin_src emacs-lisp
    (require 'server)
    (unless (server-running-p)
      (server-start))
  #+end_src

  For talking to gpg-agent, this is not so easy to get right.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun kludge-gpg-agent ()
      (if (display-graphic-p)
	  (setenv "DISPLAY" (terminal-name))
	(setenv "GPG_TTY" (terminal-name))
	(setenv "DISPLAY")))

    (add-hook 'window-configuration-change-hook 'kludge-gpg-agent)
  #+END_SRC
  Enter password in Minibuffer instead of gpg-agents pinentry program.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq epa-pinentry-mode 'loopback)
  #+END_SRC
  
** Non-Specific Keybindings

  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c r") 'replace-string) ; non-qery replace
						   ; keybinding
    (global-set-key (kbd "C-x C-b") 'ibuffer)      ; better overview of buffers
    (global-set-key (kbd "C-c c") 'comment-or-uncomment-region)
    (global-set-key (kbd "C-c u") 'uncomment-region)

    (global-set-key (kbd "C-c C-f") 'fzf)	      ;fuzzy finder
    (global-set-key (kbd "C-c f") 'fzf-directory) ;
  #+end_src

  My notebook has a problem with Shift and Meta keys at the same time,
  it will only accpet the key first pressed. This makes some commands
  unreachable. For example ~forward-paragraph~ is bound to ~C-}~,
  which involves both shift and meta. This may explain some unusual
  keybindings.
  
** Markdown
   Do not use pandoc, it has huge dependencies. Cmark is small, fast
   and works well.
   #+begin_src emacs-lisp
     (setq markdown-command "cmark")
   #+end_src

** Org Mode
*** General Org Settings
    #+begin_src emacs-lisp
      (require 'org)
      (global-set-key (kbd "C-c l") 'org-store-link)
      (global-set-key (kbd "C-c a") 'org-agenda)
      ;;(global-set-key (kbd "C-c c") 'org-capture)
      (global-set-key (kbd "C-c b") 'org-switchb)
    #+end_src

    Fix some keybindings for Org mode, my Lenovo Notebook does not like
    shift with other modifiers.
    #+begin_src emacs-lisp
      (define-key org-mode-map (kbd "<C-M-return>") 'org-insert-todo-heading)
      (define-key org-mode-map (kbd "<C-M-left>") 'org-table-delete-column)
      (define-key org-mode-map (kbd "<C-M-right>") 'org-table-insert-column)
      (define-key org-mode-map (kbd "<C-M-up>") 'org-table-kill-row)
      (define-key org-mode-map (kbd "<C-M-down>") 'org-table-insert-row)
    #+end_src
   
    Add better support for interleave mode. This mode is useful for
    making annotations and notes for PDF files.
    #+begin_src emacs-lisp
      (define-key org-mode-map (kbd "C-c i") 'interleave-mode)
    #+end_src

    Enable auto fill mode, this wraps lines when they are too long
    automatically.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-hook 'org-mode-hook 'auto-fill-mode)
    #+END_SRC

*** Handling Links
    
    Make file links behave in a sensible way. This allows for page
    numbers in links to PDF files. These will get passed to a function
    that uses an external PDF reader to open the files at this page.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq org-file-apps
	`( ("\\.pdf::\\([0-9]+\\)\\'" .
	     ,(lambda (file path)
		(let ((page
			(substring path
			  (+ (string-match "::\\([0-9]+\\)\\'" path)
			    2))))
		  (open-file file page))))
	   ("\\.pdf\\'" .
	     ,(lambda (file path)
		(open-file file)))
	   ("\\.docx?\\'" . "soffice %s")
	   ("\\.xlsx?\\'" . "soffice %s")
	   ("odt" . "soffice %s")
	   ("ods" . "soffice %s")))
    #+END_SRC

    Here is the helper function that does the work for openning files
    at a specified page in zathura.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun open-file (file &optional page)
        "opens the file FILE  or jumps to the page PAGE if already opened

      FILE gives the filename or path
      PAGE is the page number, starting at page 1 (D-Bus interface is 0 based)

      This function opens the file at the specified page or jumps to
      this page. If called without a number the file is opened without
      further options, or if the file is already open nothing is
      done. This should integrate in the desktop environment vie
      D-Bus."
        (let ((pgrep-out (with-output-to-string
                           (call-process "pgrep" nil standard-output nil
                             "-af"
                             (shell-quote-wildcard-pattern
                               (concat "zathura.*" file ".*")))))
               (page-num (if (stringp page)
                           (string-to-number page)
                           page)))
          (if (seq-empty-p pgrep-out)
            (if page
              (start-process "reader" nil "zathura"
                "--fork"
                "-P"
                (number-to-string page-num)
                file)
              (start-process "reader" nil "zathura"
                "--fork"
                file))
            (when page
              (dbus-call-method-asynchronously
                :session
                (concat "org.pwmt.zathura.PID-" (car (split-string pgrep-out)))
                "/org/pwmt/zathura"
                ;; in the D-Bus interface page numbers start at 0
                "org.pwmt.zathura" "GotoPage" nil (1- page-num))))))
    #+END_SRC

*** Code in Org Mode
    Make the code blocks appear nicer. This does not work directly
    when emacs starts in server mode, so this goes in
    ~org-mode-hook~. Obviously this changes not much for the user, if
    org mode is not turned on the variables for displaying org mode
    elements are not the most useful ones.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (require 'color)
      (require 'faces)
      (require 'org)

      (defun org-faces-setup ()
	;; only change it when the display is graphic
	(when (display-graphic-p nil)
	  (set-face-attribute 'org-block nil :background
	    (color-lighten-name
	      (face-attribute 'default :background) 2))))
      (add-hook 'org-mode-hook 'org-faces-setup)
      (setq org-src-fontify-natively t)
    #+END_SRC

    Enalbe yasnippet minor mode in Org. This allows for *fast* creation
    of code blocks. For better code block indentig set the tab to
    behave good.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (require 'yasnippet)
      (yas-reload-all)                        ;for loading own snippets
      (add-hook 'org-mode-hook #'yas-minor-mode)
      (setq org-src-tab-acts-natively t)
    #+END_SRC

    Load lisp for org-babel by default, use SLY (see [[*LISP with Sly][later]])
    #+BEGIN_SRC emacs-lisp :tangle yes
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (lisp . t)))
      (setq org-babel-lisp-eval-fn 'sly-eval)
    #+END_SRC

** PDF-Tools
   This is a better replacement for Doc-View Mode.
   #+begin_src emacs-lisp
     (pdf-tools-install)
   #+end_src

   Refine resizing PDF documents. Default value is 1.25
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq pdf-view-resize-factor 1.20)
   #+END_SRC

** Multiple Cursors
   Having more than one cursor at the same time can be handy for
   editing similar places of the document at once.
   #+begin_src emacs-lisp
     (require 'multiple-cursors)
     (global-set-key (kbd "C-s-s C-s-s") 'mc/edit-lines)
     (global-set-key (kbd "M-s-n") 'mc/mark-next-like-this)
     (global-set-key (kbd "M-s-p") 'mc/mark-previous-like-this)
     (global-set-key (kbd "C-c s-n") 'mc/mark-all-like-this)
   #+end_src

** Spell Checking
   For spell-checking ispell is used.
   
   ispell does not work very well with org mode out of the box. So I
   define some additional regexeps to skip.
   Ignore org structure blocks:
   #+begin_src emacs-lisp
     (let ( (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
	    (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
	    (begin-cap-regexp "^[ \t]*#\\+BEGIN_\\(SRC\\|HTML\\|LATEX\\|EXAMPLE\\|QUOTE\\)")
	    (end-cap-regexp "^[ \t]*#\\+END_\\(SRC\\|HTML\\|LATEX\\|EXAMPLE\\|QUOTE\\)"))
       (add-to-list 'ispell-skip-region-alist `(,begin-regexp . ,end-regexp))
       (add-to-list 'ispell-skip-region-alist `(,begin-cap-regexp . ,end-cap-regexp)))
   #+end_src

   Properties block in org do not need to be spell-checked
   #+begin_src emacs-lisp
     (add-to-list 'ispell-skip-region-alist '("\:PROPERTIES\:$" . "\:END\:$"))
     (add-to-list 'ispell-skip-region-alist '("^#\\+property\:.*$"))
   #+end_src

   Ignore title
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'ispell-skip-region-alist '("^#\\+title\:.*$"))
   #+END_SRC

   Ignore typewriter aka code markup
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'ispell-skip-region-alist '("~.*" . ".*~"))
   #+END_SRC

** EWW
   ~eww~ is a browser written in emacs lisp. Using this is useful when
   working with HTML files in emacs, e.g. writing HTML or having
   documentation as HTML.

   Make a keybinding to toggle image display.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'eww)
     (defun my/eww-toggle-images ()
       "Toggle whether images are loaded and reload the current page from cache."
       (interactive)
       (setq-local shr-inhibit-images (not shr-inhibit-images))
       (eww-reload t)
       (message "Images are now %s"
		(if shr-inhibit-images "off" "on")))

     (define-key eww-mode-map (kbd "I") #'my/eww-toggle-images)
     (define-key eww-link-keymap (kbd "I") #'my/eww-toggle-images)
   #+END_SRC
   
   Use full display features of shr by default.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default shr-inhibit-images nil)   ; toggle with `I`
     (setq-default shr-use-fonts t)          ; toggle with `F`
   #+END_SRC

** Magit
   Magit is a very good git client. It is just superior to everything
   else I tested so far.

   Make git always available.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (global-set-key (kbd "C-x g") 'magit-status)
   #+END_SRC

   Use the newer =forge= package instead of =magithub=, most features of
   magithub should be integrated into forge. The only thing that is missing is
   the dashboard view for Github. Forge allows also to use other git forges,
   such as Gitlab, Gitea or Gogs.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (with-eval-after-load 'magit
         (require 'forge))
   #+END_SRC

** Dired
   Dired is useful as a file manager, even if it lacks some features
   compared to other file managing software. By default it makes some
   strange choices for the programs to open files with.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq dired-dwim-target t)              ;guess default directory
     (require 'dired-x)
     (setq dired-guess-shell-alist-user '(("\\.pdf\\'" "zathura")
                                          ("\\.doc\\'" "libreoffice")
                                          ("\\.docx\\'" "libreoffice")
                                          ("\\.ppt\\'" "libreoffice")
                                          ("\\.pptx\\'" "libreoffice")
                                          ("\\.xls\\'" "libreoffice")
                                          ("\\.xlsx\\'" "libreoffice")))
   #+END_SRC

** AUCTeX
   For writing TeX and LaTeX documents.

   Code folding, mainly environments, also works with macros. Most
   useful: fold dwim (Do What I Mean) ~C-c C-o C-o~, fold
   buffer ~C-c C-o C-b~, fold region ~C-c C-o C-r~, fold environment
   ~C-c C-o C-e~, fold comment ~C-c C-o C-c~.
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; (add-hook 'LaTeX-mode-hook (lambda ()
     ;;                              (TeX-fold-mode 1)
     ;;                              (define-key outline-minor-mode-map (kbd "C-h")
     ;;                                'outline-hide-entry)
     ;;                              (define-key outline-minor-mode-map (kbd "C-c")
     ;;                                'outline-toggle-children)
     ;;                              (setq outline-minor-mode-prefix (kbd "C-c o"))
     ;;                              (local-set-key outline-minor-mode-prefix
     ;;                                             (lookup-key outline-minor-mode-map (kbd "C-c @")))
     ;;                                                           (outline-minor-mode)))
   #+END_SRC
   Note: it is important to change the ~outline-minor-mode-prefix~
   before loading outline mode. This includes anything that builds on
   top of outline mode, e.g. Org mode. Otherwise the keymap has to be
   modified.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq font-latex-fontify-sectioning 'color)
     (setq font-latex-fontify-script nil)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq reftex-plug-into-AUCTeX nil)
   #+END_SRC

** Ledger-mode
   Mode for managing money with help of ledger.
   
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))
   #+END_SRC

** Miscellaneous
   Avoid long confirmations
   #+begin_src emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+end_src

   UTF-8 encoding
   #+begin_src emacs-lisp
    (set-language-environment "UTF-8")
    (set-default-coding-systems 'utf-8)
   #+end_src
   
   Do not ask to save when compiling, just do it
   #+begin_src emacs-lisp
     (setq compilation-ask-about-save nil)
   #+end_src

   Use spaces instead of tabs and increase the fill column.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default indent-tabs-mode nil
                   fill-column 80)
   #+END_SRC

   Center text by default in visual ~fill-column-mode~.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default visual-fill-column-center-text t)
   #+END_SRC

   Prefer encrypted auth source
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc"))
   #+END_SRC

   Use =keychain= to get access to ssh-agent and gpg-agent. This removes
   unnecessary password prompts.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (keychain-refresh-environment)
   #+END_SRC

   Follow symlinks without asking.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq vc-follow-symlinks t)
   #+END_SRC

   Do not make another frame for ediff control panel. This keeps everything
   inside the original frame and starts the control panel as a minimal one
   liner.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
   #+END_SRC

* Font
  Use Fira Code font.  This font has ligatures built-in that are
  designed for code development.  This is an excellent font for
  coding, and as a general mono spaced font.  It builds on Fira Mono.

  Using this font is not as easy as it sounds.  Emacs does not offer
  full support for the ligatures, but with font lock there is a
  workaround.
  
  Use the X Logical Font Description for setting the font.  This is
  not very easy, but here it does the job (with many default values).
  Its size is 10.5pt.
  #+begin_src emacs-lisp
    (add-to-list 'default-frame-alist 
                 '(font . "-*-Fira Code-*-*-*-*-*-105-*-*-*-*-*-*"))
  #+end_src

  Make a big list for the ligatures.  Emacs does not support the
  ligatures of Fira Code by default, so use another font that has only
  the glyphs for the ligatures and switch to it by the use of font
  lock mode.  The font is Fira Code Symbol, for switching the fonts
  font lock mode is used.
  #+begin_src emacs-lisp
  (add-hook 'after-make-frame-functions
	(lambda (frame)
	  (set-fontset-font t '(#Xe100 . #Xe16f) (font-spec :font "Fira Code Symbol"
							    :height 105))))
							    
  (defconst fira-code-font-lock-keywords-alist
    (mapcar (lambda (regex-char-pair)
              `(,(car regex-char-pair)
                (0 (prog1 ()
                     (compose-region (match-beginning 1)
                                     (match-end 1)
                                     ;; The first argument to concat is a string containing a literal tab
                                     ,(concat "	" (list (decode-char 'ucs (cadr regex-char-pair)))))))))
            '(("\\(www\\)"                   #Xe100)
              ("[^/]\\(\\*\\*\\)[^/]"        #Xe101)
              ("\\(\\*\\*\\*\\)"             #Xe102)
              ("\\(\\*\\*/\\)"               #Xe103)
              ("\\(\\*>\\)"                  #Xe104)
              ("[^*]\\(\\*/\\)"              #Xe105)
              ("\\(\\\\\\\\\\)"              #Xe106)
              ("\\(\\\\\\\\\\\\\\)"          #Xe107)
              ("\\({-\\)"                    #Xe108)
              ("\\(\\[\\]\\)"                #Xe109)
              ("\\(::\\)"                    #Xe10a)
              ("\\(:::\\)"                   #Xe10b)
              ("[^=]\\(:=\\)"                #Xe10c)
              ("\\(!!\\)"                    #Xe10d)
              ("\\(!=\\)"                    #Xe10e)
              ("\\(!==\\)"                   #Xe10f)
              ("\\(-}\\)"                    #Xe110)
              ("\\(--\\)"                    #Xe111)
              ("\\(---\\)"                   #Xe112)
              ("\\(-->\\)"                   #Xe113)
              ("[^-]\\(->\\)"                #Xe114)
              ("\\(->>\\)"                   #Xe115)
              ("\\(-<\\)"                    #Xe116)
              ("\\(-<<\\)"                   #Xe117)
              ("\\(-~\\)"                    #Xe118)
              ("\\(#{\\)"                    #Xe119)
              ("\\(#\\[\\)"                  #Xe11a)
              ("\\(##\\)"                    #Xe11b)
              ("\\(###\\)"                   #Xe11c)
              ("\\(####\\)"                  #Xe11d)
              ("\\(#(\\)"                    #Xe11e)
              ("\\(#\\?\\)"                  #Xe11f)
              ("\\(#_\\)"                    #Xe120)
              ("\\(#_(\\)"                   #Xe121)
              ("\\(\\.-\\)"                  #Xe122)
              ("\\(\\.=\\)"                  #Xe123)
              ("\\(\\.\\.\\)"                #Xe124)
              ("\\(\\.\\.<\\)"               #Xe125)
              ("\\(\\.\\.\\.\\)"             #Xe126)
              ("\\(\\?=\\)"                  #Xe127)
              ("\\(\\?\\?\\)"                #Xe128)
              ("\\(;;\\)"                    #Xe129)
              ("\\(/\\*\\)"                  #Xe12a)
              ("\\(/\\*\\*\\)"               #Xe12b)
              ("\\(/=\\)"                    #Xe12c)
              ("\\(/==\\)"                   #Xe12d)
              ("\\(/>\\)"                    #Xe12e)
              ("\\(//\\)"                    #Xe12f)
              ("\\(///\\)"                   #Xe130)
              ("\\(&&\\)"                    #Xe131)
              ("\\(||\\)"                    #Xe132)
              ("\\(||=\\)"                   #Xe133)
              ("[^|]\\(|=\\)"                #Xe134)
              ("\\(|>\\)"                    #Xe135)
              ("\\(\\^=\\)"                  #Xe136)
              ("\\(\\$>\\)"                  #Xe137)
              ("\\(\\+\\+\\)"                #Xe138)
              ("\\(\\+\\+\\+\\)"             #Xe139)
              ("\\(\\+>\\)"                  #Xe13a)
              ("\\(=:=\\)"                   #Xe13b)
              ("[^!/]\\(==\\)[^>]"           #Xe13c)
              ("\\(===\\)"                   #Xe13d)
              ("\\(==>\\)"                   #Xe13e)
              ("[^=]\\(=>\\)"                #Xe13f)
              ("\\(=>>\\)"                   #Xe140)
              ("\\(<=\\)"                    #Xe141)
              ("\\(=<<\\)"                   #Xe142)
              ("\\(=/=\\)"                   #Xe143)
              ("\\(>-\\)"                    #Xe144)
              ("\\(>=\\)"                    #Xe145)
              ("\\(>=>\\)"                   #Xe146)
              ("[^-=]\\(>>\\)"               #Xe147)
              ("\\(>>-\\)"                   #Xe148)
              ("\\(>>=\\)"                   #Xe149)
              ("\\(>>>\\)"                   #Xe14a)
              ("\\(<\\*\\)"                  #Xe14b)
              ("\\(<\\*>\\)"                 #Xe14c)
              ("\\(<|\\)"                    #Xe14d)
              ("\\(<|>\\)"                   #Xe14e)
              ("\\(<\\$\\)"                  #Xe14f)
              ("\\(<\\$>\\)"                 #Xe150)
              ("\\(<!--\\)"                  #Xe151)
              ("\\(<-\\)"                    #Xe152)
              ("\\(<--\\)"                   #Xe153)
              ("\\(<->\\)"                   #Xe154)
              ("\\(<\\+\\)"                  #Xe155)
              ("\\(<\\+>\\)"                 #Xe156)
              ("\\(<=\\)"                    #Xe157)
              ("\\(<==\\)"                   #Xe158)
              ("\\(<=>\\)"                   #Xe159)
              ("\\(<=<\\)"                   #Xe15a)
              ("\\(<>\\)"                    #Xe15b)
              ("[^-=]\\(<<\\)"               #Xe15c)
              ("\\(<<-\\)"                   #Xe15d)
              ("\\(<<=\\)"                   #Xe15e)
              ("\\(<<<\\)"                   #Xe15f)
              ("\\(<~\\)"                    #Xe160)
              ("\\(<~~\\)"                   #Xe161)
              ("\\(</\\)"                    #Xe162)
              ("\\(</>\\)"                   #Xe163)
              ("\\(~@\\)"                    #Xe164)
              ("\\(~-\\)"                    #Xe165)
              ("\\(~=\\)"                    #Xe166)
              ("\\(~>\\)"                    #Xe167)
              ("[^<]\\(~~\\)"                #Xe168)
              ("\\(~~>\\)"                   #Xe169)
              ("[^%]\\(%%\\)[^%]"            #Xe16a) ;does not work at the
  					;beginning of a line anymore
  	    ;; ("\\(x\\)"                   #Xe16b) This ended up being hard to do properly so i'm leaving it out.
  	    ("0\\(x\\)[0-9]"               #Xe16b) ; not exactly what we
  					; want but a cheap replacement
  					; for main feature
              ("[^:=]\\(:\\)[^:=]"           #Xe16c)
              ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
              ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f))))

  #+end_src

  Now enable the ligatures.  Do this only for graphical display, as in
  my terminal emulator I use Fira Code as standard font.  Doubling the
  ligatures gives a poor result.
  #+begin_src emacs-lisp
  (defun add-fira-code-symbol-keywords ()
    (when (display-graphic-p)
      (font-lock-add-keywords nil fira-code-font-lock-keywords-alist)))
  #+end_src
  
  Enable the ligatures for the programming modes.
  #+begin_src emacs-lisp
    (add-hook 'prog-mode-hook
	      #'add-fira-code-symbol-keywords)
  #+end_src
  
* Auto Completion
** Helm
   Helm enables easy completion and selection of items, e.g. when
   choosing files or commands/functions.
   #+begin_src emacs-lisp
     (require 'helm)
     (global-set-key (kbd "M-x") #'helm-M-x)
     (global-set-key (kbd "C-x C-f") #'helm-find-files)
     (global-set-key (kbd "M-y") #'helm-show-kill-ring)
     (helm-mode 1)
   #+end_src
   
** Use company
  #+begin_src emacs-lisp
    (require 'company)
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-backends (delete 'company-semantic company-backends))
    (setq company-tooltip-align-annotations t)
  #+end_src

  Cycle through possible completions when hitting TAB several times
  #+begin_src emacs-lisp
    (substitute-key-definition 'company-complete-common
    			   'company-complete-common-or-cycle
    			   company-active-map)
    (define-key company-active-map (kbd "ESC") 'company-abort)
  #+end_src

  Make company available in C and C++ mode
  #+begin_src emacs-lisp
    (require 'cc-mode)
    (define-key c-mode-map (kbd "TAB") 'company-indent-or-complete-common)
    (define-key c++-mode-map (kbd "TAB") 'company-indent-or-complete-common)
  #+end_src

  Fix the templating made by company-clang. It is the easiest solution
  to write a company back-end that just wraps the clang back-end and
  uses these results, but does discard the call to post-complete,
  which results in template expansion.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/lisp")
    (require 'company-my-clang)
    (add-to-list 'company-backends 'company-my-clang)
  #+END_SRC

* Bibliography
** helm-bibtex
   Nice mode for organizing BibTeX references.

   Add some keybindings for navigating in the search results
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'helm-bibtex)
     (define-key biblio-selection-mode-map (kbd "p") #'biblio--selection-previous)
     (define-key biblio-selection-mode-map (kbd "n") #'biblio--selection-next)
     (define-key biblio-selection-mode-map (kbd "d")
       #'(lambda ()
           (interactive)
           (biblio-download--action (biblio--selection-metadata-at-point))))
   #+END_SRC

* Programming Modes
** Rust
   Add some useful modes, like cargo, racer and eldoc, tho the rust
   mode hook.
   #+begin_src emacs-lisp
     (require 'rust-mode)
     (add-hook 'rust-mode-hook #'cargo-minor-mode)
     (add-hook 'rust-mode-hook 'racer-mode)
     (add-hook 'racer-mode-hook #'eldoc-mode)
     (add-hook 'racer-mode-hook #'company-mode) ;make sure it is started
   #+end_src
   
   Make it work better.  Run rustfmt when saving a file, this does a
   good job and gets invoked before every cargo run, as all files need
   to be saved before compilation.  Cargo mode uses the variable
   compilation-ask-about-save, like every good mode that deals with
   compilation like stuff.  In addition racer completion inserts some
   predefined code with function completion, this is mostly
   parentheses and arguments.  It comes unhandy, so don't do this; the
   great Eldoc mode displays the help anyway when the cursor is inside
   the arguments for a function.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq rust-format-on-save t)
     (setq racer-complete-insert-argument-placeholders nil)
   #+END_SRC

   Now define some keybindings.  After the other hooks, they should
   not be overwritten by something else.
   #+begin_src emacs-lisp
     (add-hook 'racer-mode-hook
	       (lambda () 
		 (progn
		   (define-key racer-mode-map (kbd "M-.")
		     'racer-find-definition-other-window)
		   (define-key racer-mode-map (kbd "C-x 4 .")
		     'racer-find-definition)
		   (define-key racer-mode-map (kbd "C-c C-d")
		     'racer-describe))))
		   ;; this may also be useful for other modes
		   ;;(setq compilation-auto-jump-to-first-error t))))
   #+end_src

   Improve cargo mode with a command for running the release binary
   #+begin_src emacs-lisp
     (add-hook 'cargo-minor-mode-hook
	       (lambda ()
		 (progn
		   (defvar cargo-process--command-run-release "run --release")
		   (defun cargo-process-run-release ()
		     (interactive)
		     (cargo-process--start "Run" cargo-process--command-run-release))
		   (define-key cargo-minor-mode-map (kbd "C-c C-c C-SPC")
		     'cargo-process-run-release))))
   #+end_src
   
** LISP with Sly
   Sly includes more features than slime, which focusses on providing
   a very stable product.  In my opinion the additional features of
   Sly are a must have if you ever tried it, e.g. the fuzzy match
   autocompletion.
   
   Set the lisp system
   #+begin_src emacs-lisp
     (setq inferior-lisp-program "/usr/bin/sbcl")
     ;; (setq slime-contribs '(slime-fancy))
   #+end_src

   Use a local version of the Common Lisp HyperSpec and display it in
   emacs.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq common-lisp-hyperspec-root
           "file:/home/jonas/prog/HyperSpec/")
     (setq browse-url-browser-function
           '((".*home/jonas/prog/HyperSpec/.*" . eww-browse-url)
             (".*" . browse-url-default-browser)))
   #+END_SRC

** Emacs Lisp
   Use ~xref-find-definitions~ for searching definitions of functions and
   variables. Semantic does not work very well, but xref does in Emacs Lisp
   buffers.

   This turns out to be a bit demanding in this setting. The semantic mode
   binding for =M-.= should be available in other buffers, but not in Emacs Lisp
   buffers.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun local-set-minor-mode-key (mode key def)
       "Overrides a minor mode keybinding for the local
     buffer, by creating or altering keymaps stored in buffer-local
     `minor-mode-overriding-map-alist'."
       (let* ((oldmap (cdr (assoc mode minor-mode-map-alist)))
              (newmap (or (cdr (assoc mode minor-mode-overriding-map-alist))
                          (let ((map (make-sparse-keymap)))
                            (set-keymap-parent map oldmap)
                            (push `(,mode . ,map) minor-mode-overriding-map-alist)
                            map))))
         (define-key newmap key def)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-hook 'emacs-lisp-mode-hook
               (lambda ()
                 (local-set-minor-mode-key 'semantic-mode (kbd "M-.")
                                           #'xref-find-definitions)))
   #+END_SRC

** Semantic Mode
   #+begin_src emacs-lisp
     (global-ede-mode t)                      ; Enable the Project management system
     (add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-highlight-func-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-decoration-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-local-symbol-highlight-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-scheduler-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-completions-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-summary-mode)
   
     (require 'semantic/bovine/gcc)
     (semantic-mode 1)
   #+end_src

   To jump to the correct position of a function in e.g. a header file
   use ~semantic-ia-fast-jump~. This seems not to work well in the
   local project. So use a different keybinding.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (define-key c-mode-map (kbd "s-M-.") #'semantic-ia-fast-jump)
   #+END_SRC
   
   Display tags in another buffer. Bind this to =M-.= as this is the best fit
   for jumping to something interesting up to now.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun semantic-display-tag (&optional pt)
       "Display tag at point."
       (interactive "d")
       (unless pt (setq pt (point)))
       (let (analyze tag buf loc start pt)
         (when (and (setq analyze (semantic-analyze-current-context pt))
                    (setq tag (semantic-analyze-interesting-tag analyze))
                    (setq buf (semantic-tag-buffer tag))
                    (setq start (semantic-tag-start tag)))
           (with-selected-window (display-buffer buf #'display-buffer-pop-up-window)
             (goto-char start)
             (recenter)))))
     (define-key semantic-mode-map (kbd "M-.") #'semantic-display-tag)
   #+END_SRC

** Python
   Use iPython for more comfort
   #+begin_src emacs-lisp
   (require 'python)
   (setq python-shell-interpreter "ipython"
         python-shell-interpreter-args "--simple-prompt -i")
   #+end_src

   Jedi as back-end for company
   #+begin_src emacs-lisp
     (add-hook 'python-mode-hook
	       (lambda ()
	         (add-to-list 'company-backends 'company-jedi)))
     (setq jedi:environment-root "jedi")  ; or any other name you like
     (setq py-python-command "/usr/bin/python3")
     (define-key python-mode-map (kbd "TAB") 'company-indent-or-complete-common)
   #+end_src

** Code folding
   Emacs comes with a minor mode for code folding,
   hide-show-mode. Hideshow-org mode uses this mode for code folding
   by just hitting the TAB key.
   #+begin_src emacs-lisp
     (require 'hideshow-org)
     (add-hook 'prog-mode-hook
	       #'hs-org/minor-mode)
   #+end_src

** Fortran
   Use Fortran mode also for pfUnit (.pf) files, this is a unit test
   framework.
   #+begin_src emacs-lisp
     (require 'fortran)
     (require 'f90)
     (add-to-list 'auto-mode-alist '("\\.pf\\'" . fortran-mode))
   #+end_src

** C/C++
   These languages use the c-mode of Emacs, like many other,
   e.g. java, so I can handle them in one.

*** Gtags
    Not really sure if this is really a good idea. gtags itself is lacking some
    very important features like jumping to a system include file definition.
    gtags uses GNU GLOBAL for source code tagging.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq
       helm-gtags-ignore-case t
       helm-gtags-auto-update t
       helm-gtags-use-input-at-cursor t
       helm-gtags-pulse-at-cursor t
       helm-gtags-prefix-key "\C-cg"
       helm-gtags-suggested-key-mapping t
       )

      (require 'helm-gtags)
      ;; Enable helm-gtags-mode
      (add-hook 'dired-mode-hook 'helm-gtags-mode)
      (add-hook 'eshell-mode-hook 'helm-gtags-mode)
      (add-hook 'c-mode-hook 'helm-gtags-mode)
      (add-hook 'c++-mode-hook 'helm-gtags-mode)
      (add-hook 'asm-mode-hook 'helm-gtags-mode)

      (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
      (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
      (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
      (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
      (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
      (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
    #+END_SRC

*** Disassembling
    Use disaster for disassembling the code generated from the source
    of this buffer, i.e. when editing main.c generate main.o and then
    disassemble it with ~objdump~. This is a patched version also
    working with Fortran, thus also extend the fortran-mode-map.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-to-list 'load-path "~/.emacs.d/disaster")
      (require 'disaster)
      (define-key c-mode-map (kbd "C-c d") 'disaster)
      (define-key c++-mode-map (kbd "C-c d") 'disaster)
      (define-key fortran-mode-map (kbd "C-c d") 'disaster)
      (define-key f90-mode-map (kbd "C-c d") 'disaster)
      (setq disaster-objdump "objdump -d -M intel -Sl --no-show-raw-insn")
      (setq disaster-cxxflags "-march=native -O2 -g")
      (setq disaster-cflags "-march=native -O2 -g")
    #+END_SRC

** Julia
   For scientific computing, is a bit like Matlab.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'julia-mode)
     (require 'julia-repl)
   #+END_SRC

   Behave like other repl modes
   #+BEGIN_SRC emacs-lisp :tangle yes
     (define-key julia-repl-mode-map (kbd "C-c C-k") 'julia-repl-send-buffer)
     (define-key julia-repl-mode-map (kbd "C-c d") 'julia-repl-doc)
   #+END_SRC
   
   Support for resetting the Julia workspace, i.e. a complete restart
   of Julia. For development this is useful, as old versions of helper
   functions are removed.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (define-key julia-repl-mode-map (kbd "C-c M-n") 'julia-repl-reset)

     (defun julia-repl-reset ()
       "reset the julia repl"
       (interactive)
       (let (julia-inferior-buffer (julia-repl-inferior-buffer))
         (julia-repl--send-string
          "atexit( () -> run(`$(append!(Base.julia_cmd().exec, [\"-q\"]))`) ); exit()")))
   #+END_SRC
   
* E-Mail
  I use mu4e for mails. ~mu~ is just a mail-indexer for fast searches,
  mails have to be retrieved by another program. I use ~offlineimap~,
  see its [[file:~/dotfiles/offlineimap/.offlineimaprc][configuration]].
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'mu4e)

    (setq mail-user-agent 'mu4e-user-agent)
    (setq mu4e-maildir "~/Mail")		;where mails are stored
    (setq mu4e-update-interval 300)	     	;seconds to wait for updating
  #+END_SRC

  Here some general settings. These are just for convenience and don't
  do much. Use ~completing-read~, as the standard
  ~ido-completing-read~ does not integrate with helm. The index
  messages are annoying if there is something written in the
  minibuffer you want to read, e.g. a ~comleting-read~ prompt.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq mu4e-completing-read-function 'completing-read
          message-kill-buffer-on-exit t
          message-send-mail-function 'smtpmail-send-it
          mu4e-hide-index-messages t)
  #+END_SRC

  Splitting the window for viewing headers and the mails is somewhat
  unhandy here. It cannot decide whether to split vertically or
  horizontally depending on the actual window or frame dimensions.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq mu4e-split-view 'horizontal
          mu4e-headers-visible-columns 100
          mu4e-headers-visible-lines 15)
    (setq mu4e-headers-include-related nil)
  #+END_SRC

** Listing Masils
   In mu4e the mail list is called header mode. This is just the list
   of currently selected mails, e.g. in one maildir or by a
   search. Strictly speaking everything is a search in the mu and mu4e
   system. So nothing is really selected, it is more a search result.

   Set the information shown in header view mode. There are only six
   flags, so this field needs at most six chars.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'mu4e-header-info-custom
                  '(:recipnum . (:name "Number of recipients"   ; long name, as seen in the message-view
                                 :shortname "R#"                ; short name, as seen in the headers view
                                 :help "Number of recipients for this message" ; tooltip
                                 :function (lambda (msg)
                                             (format "%2d"
                                                     (+ (length (mu4e-message-field msg :to))
                                                        (length (mu4e-message-field msg :cc))))))))

     (setq mu4e-headers-fields      ;width of each field in chars
           '((:human-date .  12)
             (:flags      .   6)
             (:from-or-to .  30)
             (:recipnum   .   2)
             (:subject    . nil)))
   #+END_SRC

** Viewing Mails
   Fix the mu4e-view-mode.  As Outlook generates huge HTML messages
   with a lot of not really needed HTML code the HTML/plain-text ratio
   need to be larger.  The default scrolling is not the best, so I try
   to improve on it.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-view-html-plaintext-ratio-heuristic 10)
     ;; (setq mu4e-view-scroll-to-next nil)	;not needed anymore
     (define-key mu4e-view-mode-map (kbd "SPC") #'(lambda ()
						    (interactive)
						    (scroll-up 5)))
     (define-key mu4e-view-mode-map (kbd "S-SPC") #'(lambda ()
						    (interactive)
						    (scroll-down 5)))
   #+END_SRC

   URLs can be opened in a browser, saved to the kill ring and even be
   fetched (downloaded), but it is not possible to just display the
   URL. This is useful in many situations, and important if you don't
   exactly know whether the link is malicious or not.  Sometimes this
   is also fun for spam mails or it reveals a connection between
   different spam campaigns.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-mu4e-view-display-url ()
       (interactive)
       (mu4e~view-handle-single-url "URL to display"
	 (lambda (url)
	   (mu4e-message url))))
     (define-key mu4e-view-mode-map (kbd "l") 'my-mu4e-view-display-url)
   #+END_SRC

   Show all the addresses, not just the display names. Often funny with
   spam mails.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-view-show-addresses t)
   #+END_SRC
  
   Add the possibility to display the message in a browser with full
   standards compliant HTML engine.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'mu4e-view-actions
       '("ViewInBrowser" . mu4e-action-view-in-browser) t)
   #+END_SRC

   Register the file types that imagemagick can display.  This is
   better than opening the files in some generic document viewer like
   xpdf.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (when (fboundp 'imagemagick-register-types)
       (imagemagick-register-types))
   #+END_SRC

   Enable not only ~visual-line-mode~, but also
   ~visual-fill-column-mode~. This improves the readability.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (define-key mu4e-view-mode-map (kbd "w")
       #'(lambda ()
           (interactive)
           (visual-fill-column-mode 'toggle)
           (visual-line-mode 'toggle)))
   #+END_SRC

** Marking
   Managing mails in mu4e works via marks, this is similar to dired or
   many other list based solutions. Unfortunately all marks are
   deleted if the first action on each message is executed (it makes
   sense to do it like this), so it is not possible to mark a bunch of
   messages as read and then refile it, i.e. making an archive. So
   this approach needs a separate mark.  The dault, built-in archive
   a.k.a. refile mark does not mark messages as read, it only adds the
   seen and removes the new flag.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (plist-put (cdr (assoc 'refile mu4e-marks)) :action
                (lambda (docid msg target)
                  (mu4e~proc-move docid
                                  (mu4e~mark-check-target target)
                                  "+S-N-u")))
   #+END_SRC
   This code block changes the definition of the refile action.
   ~mu4e-marks~ is an alist that maps mark symbols to the properties.
   So I get the ~'refile~ association in the list, for further
   processing only the ~cdr~ is of interest, as this rest is a plist.
   Working with plists is very nice if you got used to it.  Adjusting
   only the ~:action~ of refile via ~plist-put~ suffices to make the
   desired changes.  The function is largely the same as the original,
   only the flags are different (mark the message as seen and read).

** Spam
   I use bogofilter with one database for all accounts for
   spamfiltering.

   #+BEGIN_SRC emacs-lisp :tangle yes
     (defcustom mu4e-junk-folder "/junk"
       "Your folder for junk/spam messages, relative to `mu4e-maildir'.
     For instance, \"/Junk\"."
       :type '(string :tag "Folder name")
       ;; '(choice
       ;;   '(string :tag "Folder name")
       ;;   (function :tag "Function return folder name"))
       :group 'mu4e-folders)

     (defgroup mu4e-spam nil
       "Spam related settings"
       :group 'mu4e)

     (defcustom mu4e-register-as-spam-cmd "/usr/bin/bogofilter -Ns < %s"
       "Command for invoking spam processor to register message as spam,
     for example for bogofilter, use \"/usr/bin/bogofilter -Ns < %s\" "
       :type '(string :tag "command")
       :group 'mu4e-spam)

     (defcustom mu4e-register-as-ham-cmd "/usr/bin/bogofilter -Sn < %s"
       "Command for invoking spam processor to register message as ham.
     For example for bogofile, use \"/usr/bin/bogofilter -Sn < %s\""
       :type '(string :tag "command")
       :group 'mu4e-spam)

     (defun mu4e-register-msg-as-spam (msg)
       "Mark message as spam and move it for junk folder"
       (interactive)
       (let* ((path (shell-quote-argument (mu4e-message-field msg :path)))
              (command (format mu4e-register-as-spam-cmd path))) ;; re-register msg as spam 
         (shell-command command))
       (mu4e-mark-at-point 'move mu4e-junk-folder))

     (defun mu4e-register-msg-as-ham (msg)
       "Mark message as ham."
       (interactive)
       (let* ((path (shell-quote-argument(mu4e-message-field msg :path)))
              (command (format mu4e-register-as-ham-cmd path))) ;; re-register msg as ham
         (shell-command command))
       (mu4e-mark-at-point 'something nil))

     (defun mu4e-view-register-msg-as-spam (msg)
       "Mark message as spam and move it to junk folder (view mode)."
       (interactive)
       (let* ((path (shell-quote-argument (mu4e-message-field msg :path)))
              (command (format mu4e-register-as-spam-cmd path)))
         (shell-command command))
       (mu4e-view-mark-for-move))

     (defun mu4e-view-register-msg-as-ham (msg)
       "Mark message as ham (view mode)."
       (interactive)
       (let* ((path (shell-quote-argument(mu4e-message-field msg :path)))
              (command (format mu4e-register-as-ham-cmd path)))
         (shell-command command))
       (mu4e-view-mark-for-something))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'mu4e-headers-actions
                  '("jMark as spam" . mu4e-register-msg-as-spam) t)
     (add-to-list 'mu4e-headers-actions
                  '("hMark as ham"  . mu4e-register-msg-as-ham) t)

     (add-to-list 'mu4e-view-actions
                  '("jMark as spam." . mu4e-view-register-msg-as-spam) t)
     (add-to-list 'mu4e-view-actions
                  '("hMark as ham."  . mu4e-view-register-msg-as-ham) t)
   #+END_SRC
   
** Accounts
   Use mu4e built in support of contexts, in other mail clients this
   would probably be called accounts or inboxes.

   For my context setup I have to do some preliminary work.  Set the
   global maildir shortcuts, these shortcuts will be available in
   every context.  Define a helper function for archiving mails in one
   folder per month.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq global-maildir-shortcuts
           '(("/DLRG-J-B/INBOX"   . ?d)
             ("/T-Online/INBOX"   . ?t)))

     (defun get-date-directory (msg)
       "Takes a message plist MSG and returns string yyyy/mm

The message MSG is expected to be in the format of mu4e
messages. It extracts the Date and returns a string suitable for
sorting mails into folders with respect to the month they were
sent."
       (let* ((date (decode-time (mu4e-message-field msg :date)))
              (month (nth 4 date))
              (year (nth 5 date)))
         (concat (int-to-string year) "/" (format "%02d" month))))
   #+END_SRC

   For sending mail use smtpmail.  The variable here is always the
   same, so there is no point in setting it for each account.  The
   SMTP standard suggests to use something like an IP address for the
   local domain, so I try to get one that is prably used for sending
   the mail (it is not as easy as it seems at a first glance, at this
   point every interface could be used, I just pick the first that is
   not a loopback device).
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq smtpmail-stream-type 'ssl)

     (defun get-connected-network-interface ()
       "Returns a alist with one connected network interface.

If only the loopback device is registered this is returned.  The
return value is an alist like `network-interface-list' return
values.  The first value, that is not the loopback device is
returned; this may not be the interface used for networking."
       (let ((int-list (network-interface-list)))
	 (if (= 1 (seq-length int-list))
	   (car int-list)
	   (car (assq-delete-all '"lo" int-list)))))

     (setq smtpmail-local-domain
       (concat "["
	 (format-network-address
	   (seq-take (cdr (get-connected-network-interface)) 4))
	 "]"))
   #+END_SRC


   Now comes the most important part of the mu4e configuration, the
   contexts. mu4e's context system allows for setting many variables
   individually for each context, or account.  There is no need that
   these variables are only those of mu4e, the context changing
   function just sets all variables specified for the new context to
   the given value.  For example you may also set some variables for
   the Emacs built-in mail support system.

   With ~mu4e-contexts~ the quoting with backtick `, single quote ',
   and comma , is important. To be honest it is always important when
   programming Lisp, but for now quoting was not necessary in this
   setup.

   A short overview:
   - ~'~  :: prevents all evaluation
   - ~`~  :: prevents most evaluation
   - ~,~  :: gets evaluated in ` quoted blocks
   - ~,@~ :: the elements of this list get spliced into the expression

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-contexts
           `(,(make-mu4e-context
               :name "T-Online"
               :enter-func (lambda () (mu4e-message "Kontext T-Online"))
               :leave-func (lambda () (mu4e-message "Verlasse T-Online"))
               :match-func (lambda (msg)
                             (when msg
                               (string-match-p "^/T-Online" (mu4e-message-field msg :maildir))))
                               ;; (or
                               ;;   (string-match-p "^/T-Online" (mu4e-message-field msg :maildir))
                               ;;   (mu4e-message-contact-field-matches msg
                               ;;     '(:to :cc :from) "jonas.kipfstuhl@t-online.de"))))
               :vars `((user-mail-address           . "jonas.kipfstuhl@t-online.de")
                       (user-full-name              . "Jonas Kipfstuhl")
                       (mu4e-sent-folder            . "/T-Online/INBOX.Sent")
                       (mu4e-drafts-folder          . "/T-Online/INBOX.Drafts")
                       (mu4e-trash-folder           . "/T-Online/INBOX.Trash")
                       (mu4e-junk-folder            . "/T-Online/INBOX.Junk")
                       (mu4e-get-mail-command       . "offlineimap -a T-Online")
                       (mu4e-query-rewrite-function . (lambda (expr)
                                                        ;; see explanation in other mu4e-context!

                                                        ;; try to understand some of the mu find
                                                        ;; syntax, at this point nothing is known
                                                        (cond
                                                         ((string-match-p "\\(^\\|[[:blank:]]\\)maildir:" expr)
                                                          expr)
                                                         ;; be a bit efficient and don't use regexps
                                                         ;; g (global) is defined as short for flags, so use
                                                         ;; a for all
                                                         ((string-equal (substring expr 0 2) "a:")
                                                          (string-trim-left (substring expr 2 nil)))
                                                         (t
                                                          (concat  "maildir:/T-Online/ " expr)))))
                       (mu4e-maildir-shortcuts      . ,(append
                                                        global-maildir-shortcuts
                                                        '(("/T-Online/INBOX"        . ?i)
                                                          ("/T-Online/INBOX.Sent"   . ?s)
                                                          ("/T-Online/INBOX.Drafts" . ?e)
                                                          ("/T-Online/INBOX.Trash"  . ?m))))
                       (smtpmail-smtp-server        . "securesmtp.t-online.de")
                       (smtpmail-smtp-service       . 465)
                       (smtpmail-smtp-user          . "jonas.kipfstuhl@t-online.de")
                       (smtpmail-mail-address       . "jonas.kipfstuhl@t-online.de")))
             ,(make-mu4e-context
               :name "DLRG"
               :enter-func (lambda () (mu4e-message "Kontext DLRG"))
               :leave-func (lambda () (mu4e-message "Verlasse DLRG"))
               :match-func (lambda (msg)
                             (when msg
                               (string-match-p "^/DLRG-J-B" (mu4e-message-field msg :maildir))))
                               ;; (or
                               ;;   (string-match-p "^/DLRG-J-B" (mu4e-message-field msg :maildir))
                               ;;   (mu4e-message-contact-field-matches msg
                               ;;     '(:to :cc :from) "jonas.kipfstuhl@bayern.dlrg-jugend.de"))))
               :vars `((user-mail-address           . "jonas.kipfstuhl@bayern.dlrg-jugend.de")
                       (user-full-name              . "Jonas Kipfstuhl")
                       (mu4e-sent-folder            . "/DLRG-J-B/INBOX.Sent")
                       (mu4e-drafts-folder          . "/DLRG-J-B/INBOX.Drafts")
                       (mu4e-trash-folder           . "/DLRG-J-B/INBOX.Trash")
                       (mu4e-junk-folder            . "/DLRG-J-B/INBOX.Junk")
                       (mu4e-refile-folder          . (lambda (msg)
                                                        (concat "/DLRG-J-B/Archiv/" (get-date-directory msg))))
                       (mu4e-get-mail-command       . "offlineimap -a DLRG-Jugend-Bayern")
                       (mu4e-query-rewrite-function . (lambda (expr)
                                                        ;; Assume that searches should be local to the
                                                        ;; mails in the current context. This coincides
                                                        ;; with a maildir, in this case. If the search
                                                        ;; starts for an explicit maildir, then do not
                                                        ;; change the query, as this query is more
                                                        ;; specific. Otherwise it would not allow to
                                                        ;; search for a specific maildir, even knowing
                                                        ;; what is done.

                                                        ;; try to understand some of the mu find
                                                        ;; syntax, at this point nothing is known
                                                        (cond
                                                         ((string-match-p "\\(^\\|[[:blank:]]\\)maildir:" expr)
                                                          expr)
                                                         ;; be a bit efficient and don't use regexps
                                                         ;; g (global) is defined as short for flags, so use
                                                         ;; a for all
                                                         ((string-equal (substring expr 0 2) "a:")
                                                          (string-trim-left (substring expr 2 nil)))
                                                         (t
                                                          (concat "maildir:/DLRG-J-B/ " expr)))))
                       (mu4e-maildir-shortcuts      . ,(append
                                                        global-maildir-shortcuts
                                                        '(("/DLRG-J-B/INBOX"        . ?i)
                                                          ("/DLRG-J-B/INBOX.Sent"   . ?s)
                                                          ("/DLRG-J-B/INBOX.Drafts" . ?e)
                                                          ("/DLRG-J-B/INBOX.Trash"  . ?m))))
                       (smtpmail-smtp-server        . "mail.dlrg.de")
                       (smtpmail-smtp-service       . 465)
                       (smtpmail-smtp-user          . "j-ljs.bayern-jonas.kipfstuhl")
                       (smtpmail-mail-address       . "jonas.kipfstuhl@bayern.dlrg-jugend.de")
                       ;; (smtpmail-local-domain       . "bayern.dlrg-jugend.de")
                       ))))
   #+END_SRC

   As ~mu4e-context-switch~ sets the variables ~mapc~-ing ~set~ over
   the list, it seems a good idea to use a context-local maildir
   prefix.  This could then get ~concat~ ed with the individual
   maildir pathes.  Unfortunately a Lisp struct holds the context
   data, this does not allow for functions.  This means the value must
   be fully expanded to something constant when the variable
   ~mu4e-contexts~ is defined.  The use of a macro or evaluating
   functions at the time the construction macro is expanded does not
   work either.  This approach would use the same value for all
   contexts.


   Generate the list of own mail addresses from the addresses defined
   in all contexts.  Manually add further addresses, that should go in
   this list.  This list is used for filtering purposes.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-user-mail-address-list
       (delq nil
	 (mapcar (lambda (context)
		   (when (mu4e-context-vars context)
		     (cdr (assq 'user-mail-address (mu4e-context-vars context)))))
	   mu4e-contexts)))
   #+END_SRC

   smtpmail can take a very long time to send the mails, specially
   when there are large attachments. To prevent this lag use
   asynchronous functions.  There are some issues with this, some
   users even report silent failures, so maybe you want to send your
   messages using another solution.
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; (require 'smtpmail-async)
     ;; (setq send-mail-function 'async-smtpmail-send-it
     ;;   message-send-mail-function 'async-smtpmail-send-it)
   #+END_SRC

* Some other ideas:
  - tramp          :: access files and directories remotely, bahaves as if tey
                      were local
  - company-bibtex :: use bibtex files as backend
  - company-reftex :: backend based on RefTeX, this is the standard in
                      emacs. Maybe a better solution than bibtex
                      only. Seems very powerful, but AucTeX centered.
  - company-math   :: completion for math typesetting, mainly LaTeX
                      and Org mode
  - writegood mode :: highlights text based on weasel-words, passive
                      voice and duplicate words.
  - writeroom-mode :: just text, no distraction, no mode-line etc
                      todo: try to disable some modes on startup,
                      e.g. company.
  - artbollocks-mode :: similar to writegood mode
  - built-in things  :: these may change a lot directly
    - line-spacing   :: set this variable in text
                        buffers.
  - visual-fill-column-mode :: use this for smaller and centered
       text areas
