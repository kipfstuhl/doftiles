#+title: Emacs configuration file
#+property: header-args:emacs-lisp :tangle yes

* Visual Appearance
  Adjust the visual things at the beginning, this prevents ugly
  changes during the startup if other parts need more time to execute.
  This leads to an impression of a fast loading init file.

  Load a color theme:
  #+begin_src emacs-lisp
    (load-theme 'tango-dark-new t)		;don't confirm the load
  #+end_src
  
  Remove the tool bar and the scroll bar, but only in graphical mode.
  In terminal mode this would result in errors or warnings.  In order
  to make this distinction, carry out the customizations when a new
  frame is made and it is graphical.  This also works in server-mode if
  it is called as ~emacsclient~, or ~emacsclient -c~.
  #+begin_src emacs-lisp
    (defun new-frame-setup (frame)
      (when (display-graphic-p frame)
	(progn
	  (tool-bar-mode -1)
	  (scroll-bar-mode -1))))
    (add-hook 'after-make-frame-functions 'new-frame-setup)
  #+end_src
  
  Allow Emacs to resize pixel-wise, not in full multiples of character
  width or height. This comes very handy, when your window manager
  leaves a small stripe of unused space next to Emacs frames
  (window manager windows).
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq frame-resize-pixelwise t)
  #+END_SRC
  
  Some unnecessary visual parts should always be removed.  Also some
  useful information is added to the mode line.
  #+begin_src emacs-lisp
    (menu-bar-mode -1)
    (blink-cursor-mode -1)
    (column-number-mode)
    (display-time-mode t)
  #+end_src
  
  Remove the start message
  #+begin_src emacs-lisp
    (setq inhibit-startup-screen t)
  #+end_src
  
* General Settings  
** Emacs Server
  Start Emacs server for being able to use emacsclient do not start it
  when already running, this is particularly useful if you edit the
  Emacs configuration and use eval-buffer for testing the effects.
  Note: it is not so easy to check whether the server is running or
  not, it just seems so. You may be surprised by the behavior!
  #+begin_src emacs-lisp
    (require 'server)
    (unless (server-running-p)
      (server-start))
  #+end_src
  
** Non-Specific Keybindings

  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c r") 'replace-string) ; non-qery replace
						   ; keybinding
    (global-set-key (kbd "C-x C-b") 'ibuffer)      ; better overview of buffers
    (global-set-key (kbd "C-c c") 'comment-or-uncomment-region)
    (global-set-key (kbd "C-c u") 'uncomment-region)

    (global-set-key (kbd "C-c C-f") 'fzf)	      ;fuzzy finder
    (global-set-key (kbd "C-c f") 'fzf-directory) ;
  #+end_src
  
** Markdown
   Do not use pandoc, it has huge dependencies. Cmark is small, fast
   and works well.
   #+begin_src emacs-lisp
     (setq markdown-command "cmark")
   #+end_src

** Org Mode
   #+begin_src emacs-lisp
     (require 'org)
     (global-set-key (kbd "C-c l") 'org-store-link)
     (global-set-key (kbd "C-c a") 'org-agenda)
     ;;(global-set-key (kbd "C-c c") 'org-capture)
     (global-set-key (kbd "C-c b") 'org-switchb)
   #+end_src

   Fix some keybindings for Org mode, my Lenovo Notebook does not like
   shift with other modifiers.
   #+begin_src emacs-lisp
     (define-key org-mode-map (kbd "<C-M-return>") 'org-insert-todo-heading)
     (define-key org-mode-map (kbd "<C-M-left>") 'org-table-delete-column)
     (define-key org-mode-map (kbd "<C-M-right>") 'org-table-insert-column)
     (define-key org-mode-map (kbd "<C-M-up>") 'org-table-kill-row)
     (define-key org-mode-map (kbd "<C-M-down>") 'org-table-insert-row)
   #+end_src
   
   Add better support for interleave mode. This mode is very useful
   for making annotations and notes for PDF files.
   #+begin_src emacs-lisp
     (define-key org-mode-map (kbd "C-c i") 'interleave-mode)
   #+end_src

** PDF-Tools
   This is a better replacement for Doc-View Mode.
   #+begin_src emacs-lisp
     (pdf-tools-install)
   #+end_src

** Multiple Cursors
   Having more than one cursor at the same time can be very handy for
   editing similar places of the document at once.
   #+begin_src emacs-lisp
     (require 'multiple-cursors)
     (global-set-key (kbd "C-s-s C-s-s") 'mc/edit-lines)
     (global-set-key (kbd "M-s-n") 'mc/mark-next-like-this)
     (global-set-key (kbd "M-s-p") 'mc/mark-previous-like-this)
     (global-set-key (kbd "C-c s-n") 'mc/mark-all-like-this)
   #+end_src

** Spell Checking
   For spell-checking ispell is used.
   
   ispell does not work very well with org mode out of the box. So I
   define some additional regexeps to skip.
   Ignore org structure blocks:
   #+begin_src emacs-lisp
     (let ( (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
	    (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
	    (begin-cap-regexp "^[ \t]*#\\+BEGIN_\\(SRC\\|HTML\\|LATEX\\|EXAMPLE\\|QUOTE\\)")
	    (end-cap-regexp "^[ \t]*#\\+END_\\(SRC\\|HTML\\|LATEX\\|EXAMPLE\\|QUOTE\\)"))
       (add-to-list 'ispell-skip-region-alist `(,begin-regexp . ,end-regexp))
       (add-to-list 'ispell-skip-region-alist `(,begin-cap-regexp . ,end-cap-regexp)))
   #+end_src

   Properties block in org do not need to be spell-checked
   #+begin_src emacs-lisp
     (add-to-list 'ispell-skip-region-alist '("\:PROPERTIES\:$" . "\:END\:$"))
     (add-to-list 'ispell-skip-region-alist '("^#\\+property\:.*$"))
   #+end_src

   Ignore title
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'ispell-skip-region-alist '("^#\\+title\:.*$"))
   #+END_SRC

   Ignore typewriter aka code markup
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'ispell-skip-region-alist '("~.*" . ".*~"))
   #+END_SRC

** Miscellaneous
   Avoid long confirmations
   #+begin_src emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+end_src

   UTF-8 encoding
   #+begin_src emacs-lisp
    (set-language-environment "UTF-8")
    (set-default-coding-systems 'utf-8)
   #+end_src
   
   Do not ask to save when compiling, just do it
   #+begin_src emacs-lisp
     (setq compilation-ask-about-save nil)
   #+end_src
   
* Font
  Use Fira Code font.  This font has ligatures built-in that are
  designed for code development.  This is a very excellent font for
  coding, and as a general mono spaced font.  It builds on Fira Mono.

  Using this font is not as easy as it sounds.  Emacs does not offer
  full support for the ligatures, but with font lock there is a
  workaround.
  
  Use the X Logical Font Description for setting the font.  This is
  not very easy, but here it does the job (with many default values).
  Its size is 10.5pt.
  #+begin_src emacs-lisp
    (add-to-list 'default-frame-alist 
                 '(font . "-*-Fira Code-*-*-*-*-*-105-*-*-*-*-*-*"))
  #+end_src

  Make a big list for the ligatures.  The ligatures are emulated with
  another font, Fira Code Symbol, and the font lock mode of Emacs is
  used for substitutions.
  #+begin_src emacs-lisp
  (add-hook 'after-make-frame-functions
	(lambda (frame)
	  (set-fontset-font t '(#Xe100 . #Xe16f) (font-spec :font "Fira Code Symbol"
							    :height 105))))
							    
  (defconst fira-code-font-lock-keywords-alist
    (mapcar (lambda (regex-char-pair)
              `(,(car regex-char-pair)
                (0 (prog1 ()
                     (compose-region (match-beginning 1)
                                     (match-end 1)
                                     ;; The first argument to concat is a string containing a literal tab
                                     ,(concat "	" (list (decode-char 'ucs (cadr regex-char-pair)))))))))
            '(("\\(www\\)"                   #Xe100)
              ("[^/]\\(\\*\\*\\)[^/]"        #Xe101)
              ("\\(\\*\\*\\*\\)"             #Xe102)
              ("\\(\\*\\*/\\)"               #Xe103)
              ("\\(\\*>\\)"                  #Xe104)
              ("[^*]\\(\\*/\\)"              #Xe105)
              ("\\(\\\\\\\\\\)"              #Xe106)
              ("\\(\\\\\\\\\\\\\\)"          #Xe107)
              ("\\({-\\)"                    #Xe108)
              ("\\(\\[\\]\\)"                #Xe109)
              ("\\(::\\)"                    #Xe10a)
              ("\\(:::\\)"                   #Xe10b)
              ("[^=]\\(:=\\)"                #Xe10c)
              ("\\(!!\\)"                    #Xe10d)
              ("\\(!=\\)"                    #Xe10e)
              ("\\(!==\\)"                   #Xe10f)
              ("\\(-}\\)"                    #Xe110)
              ("\\(--\\)"                    #Xe111)
              ("\\(---\\)"                   #Xe112)
              ("\\(-->\\)"                   #Xe113)
              ("[^-]\\(->\\)"                #Xe114)
              ("\\(->>\\)"                   #Xe115)
              ("\\(-<\\)"                    #Xe116)
              ("\\(-<<\\)"                   #Xe117)
              ("\\(-~\\)"                    #Xe118)
              ("\\(#{\\)"                    #Xe119)
              ("\\(#\\[\\)"                  #Xe11a)
              ("\\(##\\)"                    #Xe11b)
              ("\\(###\\)"                   #Xe11c)
              ("\\(####\\)"                  #Xe11d)
              ("\\(#(\\)"                    #Xe11e)
              ("\\(#\\?\\)"                  #Xe11f)
              ("\\(#_\\)"                    #Xe120)
              ("\\(#_(\\)"                   #Xe121)
              ("\\(\\.-\\)"                  #Xe122)
              ("\\(\\.=\\)"                  #Xe123)
              ("\\(\\.\\.\\)"                #Xe124)
              ("\\(\\.\\.<\\)"               #Xe125)
              ("\\(\\.\\.\\.\\)"             #Xe126)
              ("\\(\\?=\\)"                  #Xe127)
              ("\\(\\?\\?\\)"                #Xe128)
              ("\\(;;\\)"                    #Xe129)
              ("\\(/\\*\\)"                  #Xe12a)
              ("\\(/\\*\\*\\)"               #Xe12b)
              ("\\(/=\\)"                    #Xe12c)
              ("\\(/==\\)"                   #Xe12d)
              ("\\(/>\\)"                    #Xe12e)
              ("\\(//\\)"                    #Xe12f)
              ("\\(///\\)"                   #Xe130)
              ("\\(&&\\)"                    #Xe131)
              ("\\(||\\)"                    #Xe132)
              ("\\(||=\\)"                   #Xe133)
              ("[^|]\\(|=\\)"                #Xe134)
              ("\\(|>\\)"                    #Xe135)
              ("\\(\\^=\\)"                  #Xe136)
              ("\\(\\$>\\)"                  #Xe137)
              ("\\(\\+\\+\\)"                #Xe138)
              ("\\(\\+\\+\\+\\)"             #Xe139)
              ("\\(\\+>\\)"                  #Xe13a)
              ("\\(=:=\\)"                   #Xe13b)
              ("[^!/]\\(==\\)[^>]"           #Xe13c)
              ("\\(===\\)"                   #Xe13d)
              ("\\(==>\\)"                   #Xe13e)
              ("[^=]\\(=>\\)"                #Xe13f)
              ("\\(=>>\\)"                   #Xe140)
              ("\\(<=\\)"                    #Xe141)
              ("\\(=<<\\)"                   #Xe142)
              ("\\(=/=\\)"                   #Xe143)
              ("\\(>-\\)"                    #Xe144)
              ("\\(>=\\)"                    #Xe145)
              ("\\(>=>\\)"                   #Xe146)
              ("[^-=]\\(>>\\)"               #Xe147)
              ("\\(>>-\\)"                   #Xe148)
              ("\\(>>=\\)"                   #Xe149)
              ("\\(>>>\\)"                   #Xe14a)
              ("\\(<\\*\\)"                  #Xe14b)
              ("\\(<\\*>\\)"                 #Xe14c)
              ("\\(<|\\)"                    #Xe14d)
              ("\\(<|>\\)"                   #Xe14e)
              ("\\(<\\$\\)"                  #Xe14f)
              ("\\(<\\$>\\)"                 #Xe150)
              ("\\(<!--\\)"                  #Xe151)
              ("\\(<-\\)"                    #Xe152)
              ("\\(<--\\)"                   #Xe153)
              ("\\(<->\\)"                   #Xe154)
              ("\\(<\\+\\)"                  #Xe155)
              ("\\(<\\+>\\)"                 #Xe156)
              ("\\(<=\\)"                    #Xe157)
              ("\\(<==\\)"                   #Xe158)
              ("\\(<=>\\)"                   #Xe159)
              ("\\(<=<\\)"                   #Xe15a)
              ("\\(<>\\)"                    #Xe15b)
              ("[^-=]\\(<<\\)"               #Xe15c)
              ("\\(<<-\\)"                   #Xe15d)
              ("\\(<<=\\)"                   #Xe15e)
              ("\\(<<<\\)"                   #Xe15f)
              ("\\(<~\\)"                    #Xe160)
              ("\\(<~~\\)"                   #Xe161)
              ("\\(</\\)"                    #Xe162)
              ("\\(</>\\)"                   #Xe163)
              ("\\(~@\\)"                    #Xe164)
              ("\\(~-\\)"                    #Xe165)
              ("\\(~=\\)"                    #Xe166)
              ("\\(~>\\)"                    #Xe167)
              ("[^<]\\(~~\\)"                #Xe168)
              ("\\(~~>\\)"                   #Xe169)
              ("[^%]\\(%%\\)[^%]"            #Xe16a) ;does not work at the
  					;beginning of a line anymore
  	    ;; ("\\(x\\)"                   #Xe16b) This ended up being hard to do properly so i'm leaving it out.
  	    ("0\\(x\\)[0-9]"               #Xe16b) ; not exactly what we
  					; want but a cheap replacement
  					; for main feature
              ("[^:=]\\(:\\)[^:=]"           #Xe16c)
              ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
              ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f))))

  #+end_src

  Now enable the ligatures.  Do this only for graphical display, as in
  my terminal emulator Fira Code is used as standard font.  Doubling
  the ligatures gives a very poor result.
  #+begin_src emacs-lisp
  (defun add-fira-code-symbol-keywords ()
    (when (display-graphic-p)
      (font-lock-add-keywords nil fira-code-font-lock-keywords-alist)))
  #+end_src
  
  Enable the ligatures for the programming modes.
  #+begin_src emacs-lisp
    (add-hook 'prog-mode-hook
	      #'add-fira-code-symbol-keywords)
  #+end_src
  
* Auto Completion
** Helm
   Helm enables easy completion and selection of items, e.g. when
   choosing files or commands/functions.
   #+begin_src emacs-lisp
     (require 'helm)
     (global-set-key (kbd "M-x") #'helm-M-x)
     (global-set-key (kbd "C-x C-f") #'helm-find-files)
     (global-set-key (kbd "M-y") #'helm-show-kill-ring)
     (helm-mode 1)
   #+end_src
   
** Use company
  #+begin_src emacs-lisp
    (require 'company)
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-backends (delete 'company-semantic company-backends))
    (setq company-tooltip-align-annotations t)
  #+end_src

  Cycle through possible completions when hitting TAB several times
  #+begin_src emacs-lisp
    (substitute-key-definition 'company-complete-common
    			   'company-complete-common-or-cycle
    			   company-active-map)
    (define-key company-active-map (kbd "ESC") 'company-abort)
  #+end_src

  Make company available in C and C++ mode
  #+begin_src emacs-lisp
    (require 'cc-mode)
    (define-key c-mode-map (kbd "TAB") 'company-indent-or-complete-common)
    (define-key c++-mode-map (kbd "TAB") 'company-indent-or-complete-common)
  #+end_src

  Fix the templating made by company-clang. This is the easiest
  solution writing a company back-end that just wraps the clang back-end
  and uses these results, but does discard the call to post-complete,
  which results in template expansion.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/lisp")
    (require 'company-my-clang)
    (add-to-list 'company-backends 'company-my-clang)
  #+END_SRC

* Programming Modes
** Rust
   Add some useful modes, like cargo, racer and eldoc, tho the rust
   mode hook.
   #+begin_src emacs-lisp
     (require 'rust-mode)
     (add-hook 'rust-mode-hook #'cargo-minor-mode)
     (add-hook 'rust-mode-hook 'racer-mode)
     (add-hook 'racer-mode-hook #'eldoc-mode)
     (add-hook 'racer-mode-hook #'company-mode) ;make sure it is started
   #+end_src
   
   Make it work better. Run rustfmt when saving a file, this is very
   useful, as all files are saved before every cargo run. Cargo mode
   uses the variable compilation-ask-about-save, like every good mode
   that deals with compilation like stuff. In addition racer
   completion inserts some predefined code with function completion,
   this is mostly parentheses and arguments. It comes very unhandy, so
   don't do this; the help is displayed anyway when the cursor is
   inside the arguments for a function.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq rust-format-on-save t)
     (setq racer-complete-insert-argument-placeholders nil)
   #+END_SRC

   Now define some keybindings. After the other hooks, they should not
   be overwritten by something else.
   #+begin_src emacs-lisp
     (add-hook 'racer-mode-hook
	       (lambda () 
		 (progn
		   (define-key racer-mode-map (kbd "M-.")
		     'racer-find-definition-other-window)
		   (define-key racer-mode-map (kbd "C-x 4 .")
		     'racer-find-definition)
		   (define-key racer-mode-map (kbd "C-c C-d")
		     'racer-describe))))
		   ;; this may also be useful for other modes
		   ;;(setq compilation-auto-jump-to-first-error t))))
   #+end_src

   Improve cargo mode with a command for running the release binary
   #+begin_src emacs-lisp
     (add-hook 'cargo-minor-mode-hook
	       (lambda ()
		 (progn
		   (defvar cargo-process--command-run-release "run --release")
		   (defun cargo-process-run-release ()
		     (interactive)
		     (cargo-process--start "Run" cargo-process--command-run-release))
		   (define-key cargo-minor-mode-map (kbd "C-c C-c C-SPC")
		     'cargo-process-run-release))))
   #+end_src
   
** LISP with SLIME
   Set the lisp system
   #+begin_src emacs-lisp
     (setq inferior-lisp-program "/usr/bin/sbcl")
     (setq slime-contribs '(slime-fancy))
   #+end_src

   Set the indent to two spaces.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq lisp-indent-offset 2)
   #+END_SRC

** Semantic Mode
   #+begin_src emacs-lisp
     (global-ede-mode t)                      ; Enable the Project management system
     (add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-highlight-func-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-decoration-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-local-symbol-highlight-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-scheduler-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-completions-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-summary-mode)
   
     (require 'semantic/bovine/gcc)
     (semantic-mode 1)
   #+end_src

** Python
   Use iPython for more comfort
   #+begin_src emacs-lisp
   (require 'python)
   (setq python-shell-interpreter "ipython"
         python-shell-interpreter-args "--simple-prompt -i")
   #+end_src

   Jedi as back-end for company
   #+begin_src emacs-lisp
     (add-hook 'python-mode-hook
	       (lambda ()
	         (add-to-list 'company-backends 'company-jedi)))
     (setq jedi:environment-root "jedi")  ; or any other name you like
     (setq py-python-command "/usr/bin/python3")
     (define-key python-mode-map (kbd "TAB") 'company-indent-or-complete-common)
   #+end_src

** Code folding
   Emacs comes with a minor mode for code folding,
   hide-show-mode. Hideshow-org mode uses this mode for code folding
   by just hitting the TAB key.
   #+begin_src emacs-lisp
     (require 'hideshow-org)
     (add-hook 'prog-mode-hook
	       #'hs-org/minor-mode)
   #+end_src

** Fortran
   Use Fortran mode also for pfUnit (.pf) files, this is a unit test
   framework.
   #+begin_src emacs-lisp
     (require 'fortran)
     (require 'f90)
     (add-to-list 'auto-mode-alist '("\\.pf\\'" . fortran-mode))
   #+end_src

** C/C++
   These languages use the c-mode of Emacs, like many other,
   e.g. java, so I can handle them in one.
   
*** Disassembling
    Use disaster for disassembling the code generated from the source
    of this buffer, i.e. when editing main.c generate main.o and then
    disassemble it with ~objdump~. This is a patched version also
    working with Fortran, thus the fortran-mode-map also has to be
    extended.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-to-list 'load-path "~/.emacs.d/disaster")
      (require 'disaster)
      (define-key c-mode-map (kbd "C-c d") 'disaster)
      (define-key c++-mode-map (kbd "C-c d") 'disaster)
      (define-key fortran-mode-map (kbd "C-c d") 'disaster)
      (define-key f90-mode-map (kbd "C-c d") 'disaster)
      (setq disaster-objdump "objdump -d -M intel -Sl --no-show-raw-insn")
      (setq disaster-cxxflags "-march=native -O2 -g")
      (setq disaster-cflags "-march=native -O2 -g")
    #+END_SRC

* E-Mail
  I use mu4e for mails. ~mu~ is just a mail-indexer for fast searches,
  mails have to be retrieved by another program. Here ~offlineimap~ is
  used, see its [[file:~/dotfiles/offlineimap/.offlineimaprc][configuration]].
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'mu4e)

    (setq mail-user-agent 'mu4e-user-agent)
    (setq mu4e-maildir "~/Mail")		;where mails are stored
    (setq mu4e-update-interval 300)	     	;seconds to wait for updating
  #+END_SRC

  Here some general settings. These are just for convenience and don't
  do much. ~completing-read~ is used as the standard
  ~ido-completing-read~ does not integrate with helm.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq mu4e-completing-read-function 'completing-read)
    (setq message-kill-buffer-on-exit t)
    (setq mu4e-split-view 'vertical
      mu4e-headers-visible-columns 100)
  #+END_SRC

** Listing Mails
   In mu4e the mail list is called header mode. This is just the list
   of currently selected mails, e.g. in one maildir or by a search.

   Set the information that is shown in header view mode. There are
   six flags, so this field needs at most six chars.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'mu4e-header-info-custom
       '(:recipnum . ( :name "Number of recipients"  ;; long name, as seen in the message-view
		       :shortname "E#"           ;; short name, as seen in the headers view
		       :help "Number of recipients for this message" ;; tooltip
		       :function (lambda (msg)
				   (format "%2d"
				     (+ (length (mu4e-message-field msg :to))
				       (length (mu4e-message-field msg :cc))))))))

     (setq mu4e-headers-fields		;width of each field in chars
       '( (:human-date      .  12)
	  (:flags           .   6)
	  (:from-or-to      .  30)
	  (:recipnum        .   2)
	  (:thread-subject  . nil)))
   #+END_SRC


** Viewing Mails
   Fix the mu4e-view-mode. As Outlook generates huge HTML messages with
   a lot of not really needed HTML code the HTML/plain-text ratio has to
   be increased. The default scrolling is not the best, so I try to
   improve on it.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-view-html-plaintext-ratio-heuristic 10)
     ;; (setq mu4e-view-scroll-to-next nil)	;not needed anymore
     (define-key mu4e-view-mode-map (kbd "SPC") #'(lambda ()
						    (interactive)
						    (scroll-up 5)))
     (define-key mu4e-view-mode-map (kbd "S-SPC") #'(lambda ()
						    (interactive)
						    (scroll-down 5)))
   #+END_SRC

   URLs can be opened in a browser, saved to the kill
   ring and even fetched (downloaded), but it is not possible to just
   display the URL. This is useful in many situations, and important if
   you don't exactly know whether the link is malicious or not.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-mu4e-view-display-url (&optional multi)
       (interactive "P")
       (mu4e~view-handle-single-url "URL to display"
	 (lambda (url)
	   (mu4e-message url))))
     (define-key mu4e-view-mode-map (kbd "l") 'my-mu4e-view-display-url)
   #+END_SRC
  
   Show all the addresses, not just the display names. Often funny with
   spam mails.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-view-show-addresses t)
   #+END_SRC
  
   Add the possibility to display the message in a browser with full
   standards compliant HTML engine.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'mu4e-view-actions
       '("ViewInBrowser" . mu4e-action-view-in-browser) t)
   #+END_SRC

** Accounts
   Use mu4e built in support of contexts, in other mail clients this
   would probably be called accounts or inboxes.

   For my context setup some preliminary work has to be done. Set the
   global maildir shortcuts, these shortcuts will be available in every
   context. Define a helper function for archiving mails in one folder
   per month.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq global-maildir-shortcuts
       '(("/DLRG-J-B/INBOX"   . ?d)
	  ("/T-Online/INBOX"   . ?t)))

     (defun get-date-directory (msg)
       "Takes a message plist MSG and returns string yyyy/m

     The message MSG is expected to be in the format of mu4e
     messages. It extracts the Date and returns a string suitable for
     sorting mails into folders with respect to the month they were
     sent."
       (let* ((date (decode-time (mu4e-message-field msg :date)))
	       (month (nth 4 date))
	       (year (nth 5 date)))
	 (concat (int-to-string year) "/" (int-to-string month))))
   #+END_SRC

   Now comes the most important part of the mu4e configuration, the
   contexts. Many variables used by mu4e can be set via the context
   system. These variables will be used in various ways, also
   internally from the Emacs built-in mail support.

   With ~mu4e-contexts~ the quoting with backtick `, single quote ',
   and comma , is important. To be honest it is always important when
   programming Lisp, but for now quoting was not necessary in this
   setup.

   A short overview:
   - ~'~  :: prevents all evaluation
   - ~`~  :: prevents most evaluation
   - ~,~  :: gets evaluated in ` quoted blocks
   - ~,@~ :: the elements of this list get spliced into the expression

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-contexts
       `( ,(make-mu4e-context
	     :name "T-Online"
	     :enter-func (lambda () (mu4e-message "Kontext T-Online"))
	     :leave-func (lambda () (mu4e-message "Verlasse T-Online"))
	     :match-func (lambda (msg)
			   (when msg
			     (or
			       (string-match-p "^/T-Online" (mu4e-message-field msg :maildir))
			       (mu4e-message-contact-field-matches msg
				 '(:to :cc :from) "jonas.kipfstuhl@t-online.de"))))
	     :vars `( (user-mail-address      . "jonas.kipfstuhl@t-online.de")
		      (user-full-name         . "Jonas Kipfstuhl")
		      (mu4e-sent-folder       . "/T-Online/INBOX.Sent")
		      (mu4e-drafts-folder     . "/T-Online/INBOX.Drafts")
		      (mu4e-trash-folder      . "/T-Online/INBOX.Trash")
		      (mu4e-get-mail-command  . "offlineimap -a T-Online")
		      (mu4e-maildir-shortcuts . ,(append
						   global-maildir-shortcuts
						   '( ("/T-Online/INBOX"        . ?i)
						      ("/T-Online/INBOX.Sent"   . ?s)
						      ("/T-Online/INBOX.Drafts" . ?e)
						      ("/T-Online/INBOX.Trash"  . ?m))))))
	  ,(make-mu4e-context
	     :name "DLRG"
	     :enter-func (lambda () (mu4e-message "Kontext DLRG"))
	     :leave-func (lambda () (mu4e-message "Verlasse DLRG"))
	     :match-func (lambda (msg)
			   (when msg
			     (or
			       (string-match-p "^/DLRG-J-B" (mu4e-message-field msg :maildir))
			       (mu4e-message-contact-field-matches msg
				 '(:to :cc :from) "jonas.kipfstuhl@bayern.dlrg-jugend.de"))))
	     :vars `( (user-mail-address      . "jonas.kipfstuhl@bayern.dlrg-jugend.de")
		      (user-full-name         . "Jonas Kipfstuhl")
		      (mu4e-sent-folder       . "/DLRG-J-B/INBOX.Sent")
		      (mu4e-drafts-folder     . "/DLRG-J-B/INBOX.Drafts")
		      (mu4e-trash-folder      . "/DLRG-J-B/INBOX.Trash")
		      (mu4e-refile-folder     . (lambda (msg)
						  (concat "/DLRG-J-B/Archiv/" (get-date-directory msg))))
		      (mu4e-get-mail-command  . "offlineimap -a DLRG-Jugend-Bayern")
		      (mu4e-maildir-shortcuts . ,(append
						   global-maildir-shortcuts
						   '( ("/DLRG-J-B/INBOX"        . ?i)
						      ("/DLRG-J-B/INBOX.Sent"   . ?s)
						      ("/DLRG-J-B/INBOX.Drafts" . ?e)
						      ("/DLRG-J-B/INBOX.Trash"  . ?m))))))))
   #+END_SRC

   With the contexts defined the list of own mail addresses can be
   generated from the mail addresses in all contexts. If further
   addresses should go in this list, these have to be added
   manually. This list is used for filtering purposes.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-user-mail-address-list
       (delq nil
	 (mapcar (lambda (context)
		   (when (mu4e-context-vars context)
		     (cdr (assq 'user-mail-address (mu4e-context-vars context)))))
	   mu4e-contexts)))
   #+END_SRC

   smtpmail can take a very long time to send the mails, specially when
   there are large attachments. To prevent this lag use asynchronous
   functions. There are some issues with this, some users even report
   silent failures, so maybe you want to send your messages using
   another solution.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'smtpmail-async)
     (setq send-mail-function 'async-smtpmail-send-it
       message-send-mail-function 'async-smtpmail-send-it)
   #+END_SRC

