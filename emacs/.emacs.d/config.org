#+title: Emacs configuration file
#+property: header-args:emacs-lisp :tangle yes

* Visual Appearance
  Adjust the visual things at the beginning, this prevents ugly
  changes during the startup if other parts need more time to execute.
  This leads to an impression of a fast loading init file.

  Load a color theme:
  #+begin_src emacs-lisp
    (load-theme 'tango-dark-new t)		;don't confirm the load
  #+end_src
  
  Remove the tool bar and the scroll bar, but only in graphical mode.
  In terminal mode this would result in errors or warnings.  In order
  to make this distinction, carry out the customizations when a new
  frame is made and it is graphical.  This also works in server-mode if
  it is called as ~emacsclient~, or ~emacsclient -c~.
  #+begin_src emacs-lisp
    (defun new-frame-setup (frame)
      (when (display-graphic-p frame)
	(progn
	  (tool-bar-mode -1)
	  (scroll-bar-mode -1))))
    (add-hook 'after-make-frame-functions 'new-frame-setup)
  #+end_src
  
  Allow Emacs to resize pixel-wise, not in full multiples of character
  width or height. This comes very handy, when your window manager
  leaves a small stripe of unused space next to Emacs frames
  (window manager windows).
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq frame-resize-pixelwise t)
  #+END_SRC
  
  Some unnecessary visual parts should always be removed.  Also some
  useful information is added to the mode line.
  #+begin_src emacs-lisp
    (menu-bar-mode -1)
    (blink-cursor-mode -1)
    (column-number-mode)
    (display-time-mode t)
  #+end_src
  
  Remove the start message
  #+begin_src emacs-lisp
    (setq inhibit-startup-screen t)
  #+end_src
  
* General Settings  
** Emacs Server
  Start Emacs server for being able to use emacsclient do not start it
  when already running, this is particularly useful if you edit the
  Emacs configuration and use eval-buffer for testing the effects.
  Note: it is not so easy to check whether the server is running or
  not, it just seems so. You may be surprised by the behavior!
  #+begin_src emacs-lisp
    (require 'server)
    (unless (server-running-p)
      (server-start))
  #+end_src
  
** Non-Specific Keybindings

  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c r") 'replace-string) ; non-qery replace
						   ; keybinding
    (global-set-key (kbd "C-x C-b") 'ibuffer)      ; better overview of buffers
    (global-set-key (kbd "C-c c") 'comment-or-uncomment-region)
    (global-set-key (kbd "C-c u") 'uncomment-region)

    (global-set-key (kbd "C-c C-f") 'fzf)	      ;fuzzy finder
    (global-set-key (kbd "C-c f") 'fzf-directory) ;
  #+end_src
  
** Markdown
   Do not use pandoc, it has huge dependencies. Cmark is small, fast
   and works well.
   #+begin_src emacs-lisp
     (setq markdown-command "cmark")
   #+end_src

** Org Mode
*** General Org Settings
    #+begin_src emacs-lisp
      (require 'org)
      (global-set-key (kbd "C-c l") 'org-store-link)
      (global-set-key (kbd "C-c a") 'org-agenda)
      ;;(global-set-key (kbd "C-c c") 'org-capture)
      (global-set-key (kbd "C-c b") 'org-switchb)
    #+end_src

    Fix some keybindings for Org mode, my Lenovo Notebook does not like
    shift with other modifiers.
    #+begin_src emacs-lisp
      (define-key org-mode-map (kbd "<C-M-return>") 'org-insert-todo-heading)
      (define-key org-mode-map (kbd "<C-M-left>") 'org-table-delete-column)
      (define-key org-mode-map (kbd "<C-M-right>") 'org-table-insert-column)
      (define-key org-mode-map (kbd "<C-M-up>") 'org-table-kill-row)
      (define-key org-mode-map (kbd "<C-M-down>") 'org-table-insert-row)
    #+end_src
   
    Add better support for interleave mode. This mode is very useful
    for making annotations and notes for PDF files.
    #+begin_src emacs-lisp
      (define-key org-mode-map (kbd "C-c i") 'interleave-mode)
    #+end_src

    Enable auto fill mode, this wraps lines when they are too long
    automatically.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-hook 'org-mode-hook 'auto-fill-mode)
    #+END_SRC

*** Handling Links
    
    Make file links behave in a sensible way. This allows for page
    numbers in links to PDF files. These will get passed to a function
    that uses an external PDF reader to open the files at this page.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (setq org-file-apps
	`( ("\\.pdf::\\([0-9]+\\)\\'" .
	     ,(lambda (file path)
		(let ((page
			(substring path
			  (+ (string-match "::\\([0-9]+\\)\\'" path)
			    2))))
		  (open-file file page))))
	   ("\\.pdf\\'" .
	     ,(lambda (file path)
		(open-file file)))
	   ("\\.docx?\\'" . "soffice %s")
	   ("\\.xlsx?\\'" . "soffice %s")
	   ("odt" . "soffice %s")
	   ("ods" . "soffice %s")))
    #+END_SRC

    Here is the helper function that does the work for openning files
    at a specified page in zathura.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun open-file (file &optional page)
	"opens the file FILE  or jumps to the page PAGE if already opened

      FILE gives the filename or path
      PAGE is the page number, starting at page 1 (D-Bus interface is 0 based)

      This function opens the file at the specified page or jumps to
      this page. If no page number is given the file is opened without
      anything, this should integrate in the desktop environment, or if
      file is open nothing is done.
      "
	(let ((pgrep-out (with-output-to-string
			   (call-process "pgrep" nil standard-output nil
			     "-af"
			     (shell-quote-wildcard-pattern
			       (concat "zathura.*" file ".*")))))
	       (page-num (if (stringp page)
			   (string-to-number page)
			   page)))
	  (if (seq-empty-p pgrep-out)
	    (if page
	      (start-process "reader" nil "zathura"
		"--fork"
		"-P"
		(number-to-string page-num)
		file)
	      (start-process "reader" nil "zathura"
		"--fork"
		file))
	    (when page
	      (dbus-call-method-asynchronously
		:session
		(concat "org.pwmt.zathura.PID-" (car (split-string pgrep-out)))
		"/org/pwmt/zathura"
		;; in the D-Bus interface page numbers start at 0
		"org.pwmt.zathura" "GotoPage" nil (1- page-num))))))
    #+END_SRC

*** Code in Org Mode
    Make the code blocks appear nicer. This does not work directly when
    emacs is started in server mode, so this goes in
    ~org-mode-hook~. Obviously this changes not much for the user, if
    org mode is not turned on the variables for displaying org mode
    elements are not the most useful ones.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (require 'color)
      (require 'faces)
      (require 'org)

      (defun org-faces-setup ()
	;; only change it when the display is graphic
	(when (display-graphic-p nil)
	  (set-face-attribute 'org-block nil :background
	    (color-lighten-name
	      (face-attribute 'default :background) 2))))
      (add-hook 'org-mode-hook 'org-faces-setup)
      (setq org-src-fontify-natively t)
    #+END_SRC

    Enalbe yasnippet minor mode in Org. This allows for *fast* creation
    of code blocks. For better code block indentig set the tab to
    behave good.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-hook 'org-mode-hook 'yas-minor-mode)
      (setq org-src-tab-acts-natively t)
    #+END_SRC

    Load lisp for org-babel by default, use SLY (see [[*LISP with Sly][later]])
    #+BEGIN_SRC emacs-lisp :tangle yes
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (lisp . t)))
      (setq org-babel-lisp-eval-fn 'sly-eval)
    #+END_SRC

** PDF-Tools
   This is a better replacement for Doc-View Mode.
   #+begin_src emacs-lisp
     (pdf-tools-install)
   #+end_src

** Multiple Cursors
   Having more than one cursor at the same time can be very handy for
   editing similar places of the document at once.
   #+begin_src emacs-lisp
     (require 'multiple-cursors)
     (global-set-key (kbd "C-s-s C-s-s") 'mc/edit-lines)
     (global-set-key (kbd "M-s-n") 'mc/mark-next-like-this)
     (global-set-key (kbd "M-s-p") 'mc/mark-previous-like-this)
     (global-set-key (kbd "C-c s-n") 'mc/mark-all-like-this)
   #+end_src

** Spell Checking
   For spell-checking ispell is used.
   
   ispell does not work very well with org mode out of the box. So I
   define some additional regexeps to skip.
   Ignore org structure blocks:
   #+begin_src emacs-lisp
     (let ( (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
	    (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
	    (begin-cap-regexp "^[ \t]*#\\+BEGIN_\\(SRC\\|HTML\\|LATEX\\|EXAMPLE\\|QUOTE\\)")
	    (end-cap-regexp "^[ \t]*#\\+END_\\(SRC\\|HTML\\|LATEX\\|EXAMPLE\\|QUOTE\\)"))
       (add-to-list 'ispell-skip-region-alist `(,begin-regexp . ,end-regexp))
       (add-to-list 'ispell-skip-region-alist `(,begin-cap-regexp . ,end-cap-regexp)))
   #+end_src

   Properties block in org do not need to be spell-checked
   #+begin_src emacs-lisp
     (add-to-list 'ispell-skip-region-alist '("\:PROPERTIES\:$" . "\:END\:$"))
     (add-to-list 'ispell-skip-region-alist '("^#\\+property\:.*$"))
   #+end_src

   Ignore title
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'ispell-skip-region-alist '("^#\\+title\:.*$"))
   #+END_SRC

   Ignore typewriter aka code markup
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'ispell-skip-region-alist '("~.*" . ".*~"))
   #+END_SRC

** EWW
   ~eww~ is a browser written in emacs lisp. Using this is useful when
   working with HTML files in emacs, e.g. writing HTML or having
   documentation as HTML.

   Make a keybinding to toggle image display.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (require 'eww)
     (defun my/eww-toggle-images ()
       "Toggle whether images are loaded and reload the current page from cache."
       (interactive)
       (setq-local shr-inhibit-images (not shr-inhibit-images))
       (eww-reload t)
       (message "Images are now %s"
		(if shr-inhibit-images "off" "on")))

     (define-key eww-mode-map (kbd "I") #'my/eww-toggle-images)
     (define-key eww-link-keymap (kbd "I") #'my/eww-toggle-images)
   #+END_SRC
   
   Use full display features of shr by default.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default shr-inhibit-images nil)   ; toggle with `I`
     (setq-default shr-use-fonts t)          ; toggle with `F`
   #+END_SRC

** Miscellaneous
   Avoid long confirmations
   #+begin_src emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+end_src

   UTF-8 encoding
   #+begin_src emacs-lisp
    (set-language-environment "UTF-8")
    (set-default-coding-systems 'utf-8)
   #+end_src
   
   Do not ask to save when compiling, just do it
   #+begin_src emacs-lisp
     (setq compilation-ask-about-save nil)
   #+end_src

   Use spaces instead of tabs.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq-default indent-tabs-mode nil)
   #+END_SRC
   
* Font
  Use Fira Code font.  This font has ligatures built-in that are
  designed for code development.  This is a very excellent font for
  coding, and as a general mono spaced font.  It builds on Fira Mono.

  Using this font is not as easy as it sounds.  Emacs does not offer
  full support for the ligatures, but with font lock there is a
  workaround.
  
  Use the X Logical Font Description for setting the font.  This is
  not very easy, but here it does the job (with many default values).
  Its size is 10.5pt.
  #+begin_src emacs-lisp
    (add-to-list 'default-frame-alist 
                 '(font . "-*-Fira Code-*-*-*-*-*-105-*-*-*-*-*-*"))
  #+end_src

  Make a big list for the ligatures.  The ligatures are emulated with
  another font, Fira Code Symbol, and the font lock mode of Emacs is
  used for substitutions.
  #+begin_src emacs-lisp
  (add-hook 'after-make-frame-functions
	(lambda (frame)
	  (set-fontset-font t '(#Xe100 . #Xe16f) (font-spec :font "Fira Code Symbol"
							    :height 105))))
							    
  (defconst fira-code-font-lock-keywords-alist
    (mapcar (lambda (regex-char-pair)
              `(,(car regex-char-pair)
                (0 (prog1 ()
                     (compose-region (match-beginning 1)
                                     (match-end 1)
                                     ;; The first argument to concat is a string containing a literal tab
                                     ,(concat "	" (list (decode-char 'ucs (cadr regex-char-pair)))))))))
            '(("\\(www\\)"                   #Xe100)
              ("[^/]\\(\\*\\*\\)[^/]"        #Xe101)
              ("\\(\\*\\*\\*\\)"             #Xe102)
              ("\\(\\*\\*/\\)"               #Xe103)
              ("\\(\\*>\\)"                  #Xe104)
              ("[^*]\\(\\*/\\)"              #Xe105)
              ("\\(\\\\\\\\\\)"              #Xe106)
              ("\\(\\\\\\\\\\\\\\)"          #Xe107)
              ("\\({-\\)"                    #Xe108)
              ("\\(\\[\\]\\)"                #Xe109)
              ("\\(::\\)"                    #Xe10a)
              ("\\(:::\\)"                   #Xe10b)
              ("[^=]\\(:=\\)"                #Xe10c)
              ("\\(!!\\)"                    #Xe10d)
              ("\\(!=\\)"                    #Xe10e)
              ("\\(!==\\)"                   #Xe10f)
              ("\\(-}\\)"                    #Xe110)
              ("\\(--\\)"                    #Xe111)
              ("\\(---\\)"                   #Xe112)
              ("\\(-->\\)"                   #Xe113)
              ("[^-]\\(->\\)"                #Xe114)
              ("\\(->>\\)"                   #Xe115)
              ("\\(-<\\)"                    #Xe116)
              ("\\(-<<\\)"                   #Xe117)
              ("\\(-~\\)"                    #Xe118)
              ("\\(#{\\)"                    #Xe119)
              ("\\(#\\[\\)"                  #Xe11a)
              ("\\(##\\)"                    #Xe11b)
              ("\\(###\\)"                   #Xe11c)
              ("\\(####\\)"                  #Xe11d)
              ("\\(#(\\)"                    #Xe11e)
              ("\\(#\\?\\)"                  #Xe11f)
              ("\\(#_\\)"                    #Xe120)
              ("\\(#_(\\)"                   #Xe121)
              ("\\(\\.-\\)"                  #Xe122)
              ("\\(\\.=\\)"                  #Xe123)
              ("\\(\\.\\.\\)"                #Xe124)
              ("\\(\\.\\.<\\)"               #Xe125)
              ("\\(\\.\\.\\.\\)"             #Xe126)
              ("\\(\\?=\\)"                  #Xe127)
              ("\\(\\?\\?\\)"                #Xe128)
              ("\\(;;\\)"                    #Xe129)
              ("\\(/\\*\\)"                  #Xe12a)
              ("\\(/\\*\\*\\)"               #Xe12b)
              ("\\(/=\\)"                    #Xe12c)
              ("\\(/==\\)"                   #Xe12d)
              ("\\(/>\\)"                    #Xe12e)
              ("\\(//\\)"                    #Xe12f)
              ("\\(///\\)"                   #Xe130)
              ("\\(&&\\)"                    #Xe131)
              ("\\(||\\)"                    #Xe132)
              ("\\(||=\\)"                   #Xe133)
              ("[^|]\\(|=\\)"                #Xe134)
              ("\\(|>\\)"                    #Xe135)
              ("\\(\\^=\\)"                  #Xe136)
              ("\\(\\$>\\)"                  #Xe137)
              ("\\(\\+\\+\\)"                #Xe138)
              ("\\(\\+\\+\\+\\)"             #Xe139)
              ("\\(\\+>\\)"                  #Xe13a)
              ("\\(=:=\\)"                   #Xe13b)
              ("[^!/]\\(==\\)[^>]"           #Xe13c)
              ("\\(===\\)"                   #Xe13d)
              ("\\(==>\\)"                   #Xe13e)
              ("[^=]\\(=>\\)"                #Xe13f)
              ("\\(=>>\\)"                   #Xe140)
              ("\\(<=\\)"                    #Xe141)
              ("\\(=<<\\)"                   #Xe142)
              ("\\(=/=\\)"                   #Xe143)
              ("\\(>-\\)"                    #Xe144)
              ("\\(>=\\)"                    #Xe145)
              ("\\(>=>\\)"                   #Xe146)
              ("[^-=]\\(>>\\)"               #Xe147)
              ("\\(>>-\\)"                   #Xe148)
              ("\\(>>=\\)"                   #Xe149)
              ("\\(>>>\\)"                   #Xe14a)
              ("\\(<\\*\\)"                  #Xe14b)
              ("\\(<\\*>\\)"                 #Xe14c)
              ("\\(<|\\)"                    #Xe14d)
              ("\\(<|>\\)"                   #Xe14e)
              ("\\(<\\$\\)"                  #Xe14f)
              ("\\(<\\$>\\)"                 #Xe150)
              ("\\(<!--\\)"                  #Xe151)
              ("\\(<-\\)"                    #Xe152)
              ("\\(<--\\)"                   #Xe153)
              ("\\(<->\\)"                   #Xe154)
              ("\\(<\\+\\)"                  #Xe155)
              ("\\(<\\+>\\)"                 #Xe156)
              ("\\(<=\\)"                    #Xe157)
              ("\\(<==\\)"                   #Xe158)
              ("\\(<=>\\)"                   #Xe159)
              ("\\(<=<\\)"                   #Xe15a)
              ("\\(<>\\)"                    #Xe15b)
              ("[^-=]\\(<<\\)"               #Xe15c)
              ("\\(<<-\\)"                   #Xe15d)
              ("\\(<<=\\)"                   #Xe15e)
              ("\\(<<<\\)"                   #Xe15f)
              ("\\(<~\\)"                    #Xe160)
              ("\\(<~~\\)"                   #Xe161)
              ("\\(</\\)"                    #Xe162)
              ("\\(</>\\)"                   #Xe163)
              ("\\(~@\\)"                    #Xe164)
              ("\\(~-\\)"                    #Xe165)
              ("\\(~=\\)"                    #Xe166)
              ("\\(~>\\)"                    #Xe167)
              ("[^<]\\(~~\\)"                #Xe168)
              ("\\(~~>\\)"                   #Xe169)
              ("[^%]\\(%%\\)[^%]"            #Xe16a) ;does not work at the
  					;beginning of a line anymore
  	    ;; ("\\(x\\)"                   #Xe16b) This ended up being hard to do properly so i'm leaving it out.
  	    ("0\\(x\\)[0-9]"               #Xe16b) ; not exactly what we
  					; want but a cheap replacement
  					; for main feature
              ("[^:=]\\(:\\)[^:=]"           #Xe16c)
              ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
              ("[^\\*/<>]\\(\\*\\)[^\\*/<>]" #Xe16f))))

  #+end_src

  Now enable the ligatures.  Do this only for graphical display, as in
  my terminal emulator Fira Code is used as standard font.  Doubling
  the ligatures gives a very poor result.
  #+begin_src emacs-lisp
  (defun add-fira-code-symbol-keywords ()
    (when (display-graphic-p)
      (font-lock-add-keywords nil fira-code-font-lock-keywords-alist)))
  #+end_src
  
  Enable the ligatures for the programming modes.
  #+begin_src emacs-lisp
    (add-hook 'prog-mode-hook
	      #'add-fira-code-symbol-keywords)
  #+end_src
  
* Auto Completion
** Helm
   Helm enables easy completion and selection of items, e.g. when
   choosing files or commands/functions.
   #+begin_src emacs-lisp
     (require 'helm)
     (global-set-key (kbd "M-x") #'helm-M-x)
     (global-set-key (kbd "C-x C-f") #'helm-find-files)
     (global-set-key (kbd "M-y") #'helm-show-kill-ring)
     (helm-mode 1)
   #+end_src
   
** Use company
  #+begin_src emacs-lisp
    (require 'company)
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-backends (delete 'company-semantic company-backends))
    (setq company-tooltip-align-annotations t)
  #+end_src

  Cycle through possible completions when hitting TAB several times
  #+begin_src emacs-lisp
    (substitute-key-definition 'company-complete-common
    			   'company-complete-common-or-cycle
    			   company-active-map)
    (define-key company-active-map (kbd "ESC") 'company-abort)
  #+end_src

  Make company available in C and C++ mode
  #+begin_src emacs-lisp
    (require 'cc-mode)
    (define-key c-mode-map (kbd "TAB") 'company-indent-or-complete-common)
    (define-key c++-mode-map (kbd "TAB") 'company-indent-or-complete-common)
  #+end_src

  Fix the templating made by company-clang. This is the easiest
  solution writing a company back-end that just wraps the clang back-end
  and uses these results, but does discard the call to post-complete,
  which results in template expansion.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (add-to-list 'load-path "~/.emacs.d/lisp")
    (require 'company-my-clang)
    (add-to-list 'company-backends 'company-my-clang)
  #+END_SRC

* Programming Modes
** Rust
   Add some useful modes, like cargo, racer and eldoc, tho the rust
   mode hook.
   #+begin_src emacs-lisp
     (require 'rust-mode)
     (add-hook 'rust-mode-hook #'cargo-minor-mode)
     (add-hook 'rust-mode-hook 'racer-mode)
     (add-hook 'racer-mode-hook #'eldoc-mode)
     (add-hook 'racer-mode-hook #'company-mode) ;make sure it is started
   #+end_src
   
   Make it work better. Run rustfmt when saving a file, this is very
   useful, as all files are saved before every cargo run. Cargo mode
   uses the variable compilation-ask-about-save, like every good mode
   that deals with compilation like stuff. In addition racer
   completion inserts some predefined code with function completion,
   this is mostly parentheses and arguments. It comes very unhandy, so
   don't do this; the help is displayed anyway when the cursor is
   inside the arguments for a function.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq rust-format-on-save t)
     (setq racer-complete-insert-argument-placeholders nil)
   #+END_SRC

   Now define some keybindings. After the other hooks, they should not
   be overwritten by something else.
   #+begin_src emacs-lisp
     (add-hook 'racer-mode-hook
	       (lambda () 
		 (progn
		   (define-key racer-mode-map (kbd "M-.")
		     'racer-find-definition-other-window)
		   (define-key racer-mode-map (kbd "C-x 4 .")
		     'racer-find-definition)
		   (define-key racer-mode-map (kbd "C-c C-d")
		     'racer-describe))))
		   ;; this may also be useful for other modes
		   ;;(setq compilation-auto-jump-to-first-error t))))
   #+end_src

   Improve cargo mode with a command for running the release binary
   #+begin_src emacs-lisp
     (add-hook 'cargo-minor-mode-hook
	       (lambda ()
		 (progn
		   (defvar cargo-process--command-run-release "run --release")
		   (defun cargo-process-run-release ()
		     (interactive)
		     (cargo-process--start "Run" cargo-process--command-run-release))
		   (define-key cargo-minor-mode-map (kbd "C-c C-c C-SPC")
		     'cargo-process-run-release))))
   #+end_src
   
** LISP with Sly
   Sly includes more features than slime, which is focused on
   providing a very stable product. In my opinion the additional
   features of Sly are a must have if you ever tried it, e.g. the
   fuzzy match autocompletion.
   
   Set the lisp system
   #+begin_src emacs-lisp
     (setq inferior-lisp-program "/usr/bin/sbcl")
     ;; (setq slime-contribs '(slime-fancy))
   #+end_src

   Use a local version of the Common Lisp HyperSpec and display it in
   emacs.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq common-lisp-hyperspec-root
           "file:/home/jonas/prog/HyperSpec/")
     (setq browse-url-browser-function
           '((".*home/jonas/prog/HyperSpec/.*" . eww-browse-url)
             (".*" . browse-url-default-browser)))
   #+END_SRC

** Semantic Mode
   #+begin_src emacs-lisp
     (global-ede-mode t)                      ; Enable the Project management system
     (add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-highlight-func-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-decoration-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-local-symbol-highlight-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-scheduler-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-completions-mode)
     (add-to-list 'semantic-default-submodes 'global-semantic-idle-summary-mode)
   
     (require 'semantic/bovine/gcc)
     (semantic-mode 1)
   #+end_src

** Python
   Use iPython for more comfort
   #+begin_src emacs-lisp
   (require 'python)
   (setq python-shell-interpreter "ipython"
         python-shell-interpreter-args "--simple-prompt -i")
   #+end_src

   Jedi as back-end for company
   #+begin_src emacs-lisp
     (add-hook 'python-mode-hook
	       (lambda ()
	         (add-to-list 'company-backends 'company-jedi)))
     (setq jedi:environment-root "jedi")  ; or any other name you like
     (setq py-python-command "/usr/bin/python3")
     (define-key python-mode-map (kbd "TAB") 'company-indent-or-complete-common)
   #+end_src

** Code folding
   Emacs comes with a minor mode for code folding,
   hide-show-mode. Hideshow-org mode uses this mode for code folding
   by just hitting the TAB key.
   #+begin_src emacs-lisp
     (require 'hideshow-org)
     (add-hook 'prog-mode-hook
	       #'hs-org/minor-mode)
   #+end_src

** Fortran
   Use Fortran mode also for pfUnit (.pf) files, this is a unit test
   framework.
   #+begin_src emacs-lisp
     (require 'fortran)
     (require 'f90)
     (add-to-list 'auto-mode-alist '("\\.pf\\'" . fortran-mode))
   #+end_src

** C/C++
   These languages use the c-mode of Emacs, like many other,
   e.g. java, so I can handle them in one.
   
*** Disassembling
    Use disaster for disassembling the code generated from the source
    of this buffer, i.e. when editing main.c generate main.o and then
    disassemble it with ~objdump~. This is a patched version also
    working with Fortran, thus the fortran-mode-map also has to be
    extended.
    #+BEGIN_SRC emacs-lisp :tangle yes
      (add-to-list 'load-path "~/.emacs.d/disaster")
      (require 'disaster)
      (define-key c-mode-map (kbd "C-c d") 'disaster)
      (define-key c++-mode-map (kbd "C-c d") 'disaster)
      (define-key fortran-mode-map (kbd "C-c d") 'disaster)
      (define-key f90-mode-map (kbd "C-c d") 'disaster)
      (setq disaster-objdump "objdump -d -M intel -Sl --no-show-raw-insn")
      (setq disaster-cxxflags "-march=native -O2 -g")
      (setq disaster-cflags "-march=native -O2 -g")
    #+END_SRC

* E-Mail
  I use mu4e for mails. ~mu~ is just a mail-indexer for fast searches,
  mails have to be retrieved by another program. Here ~offlineimap~ is
  used, see its [[file:~/dotfiles/offlineimap/.offlineimaprc][configuration]].
  #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'mu4e)

    (setq mail-user-agent 'mu4e-user-agent)
    (setq mu4e-maildir "~/Mail")		;where mails are stored
    (setq mu4e-update-interval 300)	     	;seconds to wait for updating
  #+END_SRC

  Here some general settings. These are just for convenience and don't
  do much. ~completing-read~ is used, as the standard
  ~ido-completing-read~ does not integrate with helm.
  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq mu4e-completing-read-function 'completing-read)
    (setq message-kill-buffer-on-exit t)
    (setq message-send-mail-function 'smtpmail-send-it)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq mu4e-split-view 'vertical
      mu4e-headers-visible-columns 100)
    (setq mu4e-headers-include-related nil)
  #+END_SRC

** Listing Mails
   In mu4e the mail list is called header mode. This is just the list
   of currently selected mails, e.g. in one maildir or by a search.

   Set the information that is shown in header view mode. There are
   six flags, so this field needs at most six chars.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'mu4e-header-info-custom
       '(:recipnum . ( :name "Number of recipients"  ;; long name, as seen in the message-view
		       :shortname "E#"           ;; short name, as seen in the headers view
		       :help "Number of recipients for this message" ;; tooltip
		       :function (lambda (msg)
				   (format "%2d"
				     (+ (length (mu4e-message-field msg :to))
				       (length (mu4e-message-field msg :cc))))))))

     (setq mu4e-headers-fields		;width of each field in chars
       '( (:human-date      .  12)
	  (:flags           .   6)
	  (:from-or-to      .  30)
	  (:recipnum        .   2)
	  (:subject         . nil)))
   #+END_SRC

** Viewing Mails
   Fix the mu4e-view-mode. As Outlook generates huge HTML messages with
   a lot of not really needed HTML code the HTML/plain-text ratio has to
   be increased. The default scrolling is not the best, so I try to
   improve on it.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-view-html-plaintext-ratio-heuristic 10)
     ;; (setq mu4e-view-scroll-to-next nil)	;not needed anymore
     (define-key mu4e-view-mode-map (kbd "SPC") #'(lambda ()
						    (interactive)
						    (scroll-up 5)))
     (define-key mu4e-view-mode-map (kbd "S-SPC") #'(lambda ()
						    (interactive)
						    (scroll-down 5)))
   #+END_SRC

   URLs can be opened in a browser, saved to the kill
   ring and even fetched (downloaded), but it is not possible to just
   display the URL. This is useful in many situations, and important if
   you don't exactly know whether the link is malicious or not.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (defun my-mu4e-view-display-url ()
       (interactive)
       (mu4e~view-handle-single-url "URL to display"
	 (lambda (url)
	   (mu4e-message url))))
     (define-key mu4e-view-mode-map (kbd "l") 'my-mu4e-view-display-url)
   #+END_SRC

   Show all the addresses, not just the display names. Often funny with
   spam mails.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-view-show-addresses t)
   #+END_SRC
  
   Add the possibility to display the message in a browser with full
   standards compliant HTML engine.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (add-to-list 'mu4e-view-actions
       '("ViewInBrowser" . mu4e-action-view-in-browser) t)
   #+END_SRC

** Accounts
   Use mu4e built in support of contexts, in other mail clients this
   would probably be called accounts or inboxes.

   For my context setup some preliminary work has to be done. Set the
   global maildir shortcuts, these shortcuts will be available in every
   context. Define a helper function for archiving mails in one folder
   per month.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq global-maildir-shortcuts
       '(("/DLRG-J-B/INBOX"   . ?d)
	  ("/T-Online/INBOX"   . ?t)))

     (defun get-date-directory (msg)
       "Takes a message plist MSG and returns string yyyy/m

The message MSG is expected to be in the format of mu4e
messages. It extracts the Date and returns a string suitable for
sorting mails into folders with respect to the month they were
sent."
       (let* ((date (decode-time (mu4e-message-field msg :date)))
	       (month (nth 4 date))
	       (year (nth 5 date)))
	 (concat (int-to-string year) "/" (format "%02d" month))))
   #+END_SRC

   For sending mail use smtpmail.  These variables here are always the
   same, so there is no point in setting them for each account.  The
   SMTP standard suggests to use something like an IP address, so it
   try to get one that may be used for sending the mail (it is not as
   easy as it seems at a firs glance).
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq smtpmail-stream-type 'ssl)

     (defun get-connected-network-interface ()
       "Returns a alist with one connected network interface.

If only the loopback device is registered this is returned.  The
return value is an alist like `network-interface-list' return
values.  The first value, that is not the loopback device is
returned; this may not be the interface used for networking."
       (let ((int-list (network-interface-list)))
	 (if (= 1 (seq-length int-list))
	   (car int-list)
	   (car (assq-delete-all '"lo" int-list)))))


     (setq smtpmail-local-domain
       (concat "["
	 (format-network-address
	   (seq-take (cdr (get-connected-network-interface)) 4))
	 "]"))
   #+END_SRC


   Now comes the most important part of the mu4e configuration, the
   contexts. Many variables used by mu4e can be set via the context
   system. These variables will be used in various ways, also
   internally from the Emacs built-in mail support.

   With ~mu4e-contexts~ the quoting with backtick `, single quote ',
   and comma , is important. To be honest it is always important when
   programming Lisp, but for now quoting was not necessary in this
   setup.

   A short overview:
   - ~'~  :: prevents all evaluation
   - ~`~  :: prevents most evaluation
   - ~,~  :: gets evaluated in ` quoted blocks
   - ~,@~ :: the elements of this list get spliced into the expression

   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-contexts
       `( ,(make-mu4e-context
             :name "T-Online"
             :enter-func (lambda () (mu4e-message "Kontext T-Online"))
             :leave-func (lambda () (mu4e-message "Verlasse T-Online"))
             :match-func (lambda (msg)
                           (when msg
                             (string-match-p "^/T-Online" (mu4e-message-field msg :maildir))))
                             ;; (or
                             ;;   (string-match-p "^/T-Online" (mu4e-message-field msg :maildir))
                             ;;   (mu4e-message-contact-field-matches msg
                             ;;     '(:to :cc :from) "jonas.kipfstuhl@t-online.de"))))
             :vars `( (user-mail-address           . "jonas.kipfstuhl@t-online.de")
                      (user-full-name              . "Jonas Kipfstuhl")
                      (mu4e-sent-folder            . "/T-Online/INBOX.Sent")
                      (mu4e-drafts-folder          . "/T-Online/INBOX.Drafts")
                      (mu4e-trash-folder           . "/T-Online/INBOX.Trash")
                      (mu4e-get-mail-command       . "offlineimap -a T-Online")
                      (mu4e-query-rewrite-function . (lambda (expr)
                                                       ;; try to understand some of the mu find
                                                       ;; syntax, at this point nothing is known
                                                       (cond
                                                         ((string-match-p "\\(^\\|[[:blank:]]\\)maildir:" expr)
                                                           expr)
                                                         ;; be a bit efficient and don't use regexps
                                                         ;; g (global) is defined as short for flags, so use
                                                         ;; a for all
                                                         ((string-equal (substring expr 0 2) "a:")
                                                           (string-trim-left (substring expr 2 nil)))
                                                         (t
                                                           (concat  "maildir:/T-Online/ " expr)))))
                      (mu4e-maildir-shortcuts      . ,(append
                                                        global-maildir-shortcuts
                                                        '( ("/T-Online/INBOX"        . ?i)
                                                           ("/T-Online/INBOX.Sent"   . ?s)
                                                           ("/T-Online/INBOX.Drafts" . ?e)
                                                           ("/T-Online/INBOX.Trash"  . ?m))))
                      (smtpmail-smtp-server        . "securesmtp.t-online.de")
                      (smtpmail-smtp-service       . 465)
                      (smtpmail-smtp-user          . "jonas.kipfstuhl@t-online.de")
                      (smtpmail-mail-address       . "jonas.kipfstuhl@t-online.de")))
          ,(make-mu4e-context
             :name "DLRG"
             :enter-func (lambda () (mu4e-message "Kontext DLRG"))
             :leave-func (lambda () (mu4e-message "Verlasse DLRG"))
             :match-func (lambda (msg)
                           (when msg
                             (string-match-p "^/DLRG-J-B" (mu4e-message-field msg :maildir))))
                             ;; (or
                             ;;   (string-match-p "^/DLRG-J-B" (mu4e-message-field msg :maildir))
                             ;;   (mu4e-message-contact-field-matches msg
                             ;;     '(:to :cc :from) "jonas.kipfstuhl@bayern.dlrg-jugend.de"))))
             :vars `( (user-mail-address           . "jonas.kipfstuhl@bayern.dlrg-jugend.de")
                      (user-full-name              . "Jonas Kipfstuhl")
                      (mu4e-sent-folder            . "/DLRG-J-B/INBOX.Sent")
                      (mu4e-drafts-folder          . "/DLRG-J-B/INBOX.Drafts")
                      (mu4e-trash-folder           . "/DLRG-J-B/INBOX.Trash")
                      (mu4e-refile-folder          . (lambda (msg)
                                                       (concat "/DLRG-J-B/Archiv/" (get-date-directory msg))))
                      (mu4e-get-mail-command       . "offlineimap -a DLRG-Jugend-Bayern")
                      (mu4e-query-rewrite-function . (lambda (expr)
                                                       ;; try to understand some of the mu find
                                                       ;; syntax, at this point nothing is known
                                                       (cond
                                                         ((string-match-p "\\(^\\|[[:blank:]]\\)maildir:" expr)
                                                           expr)
                                                         ;; be a bit efficient and don't use regexps
                                                         ;; g (global) is defined as short for flags, so use
                                                         ;; a for all
                                                         ((string-equal (substring expr 0 2) "a:")
                                                           (string-trim-left (substring expr 2 nil)))
                                                         (t
                                                           (concat "maildir:/DLRG-J-B/ " expr)))))
                      (mu4e-maildir-shortcuts      . ,(append
                                                        global-maildir-shortcuts
                                                        '( ("/DLRG-J-B/INBOX"        . ?i)
                                                           ("/DLRG-J-B/INBOX.Sent"   . ?s)
                                                           ("/DLRG-J-B/INBOX.Drafts" . ?e)
                                                           ("/DLRG-J-B/INBOX.Trash"  . ?m))))
                      (smtpmail-smtp-server        . "mail.dlrg.de")
                      (smtpmail-smtp-service       . 465)
                      (smtpmail-smtp-user          . "j-ljs.bayern-jonas.kipfstuhl")
                      (smtpmail-mail-address       . "jonas.kipfstuhl@bayern.dlrg-jugend.de")
                      ;; (smtpmail-local-domain       . "bayern.dlrg-jugend.de")
                      ))))
   #+END_SRC

   As ~mu4e-context-switch~ sets the variables ~mapc~ ing ~set~ over
   the list, it seems a good idea to use a context-local maildir
   prefix. This could then get ~concat~ ed with the individual maildir
   pathes. Unfortunately the context data is stored in a Lisp struct,
   this does not allow for functions. This means the value must be
   fully expanded to something constant when the variable
   ~mu4e-contexts~ is defined. The use of a macro or evaluating
   functions at the time the construction macro is expanded does not
   work either. This approach would use the same value for all
   contexts.

   With the contexts defined the list of own mail addresses can be
   generated from the mail addresses in all contexts. If further
   addresses should go in this list, these have to be added
   manually. This list is used for filtering purposes.
   #+BEGIN_SRC emacs-lisp :tangle yes
     (setq mu4e-user-mail-address-list
       (delq nil
	 (mapcar (lambda (context)
		   (when (mu4e-context-vars context)
		     (cdr (assq 'user-mail-address (mu4e-context-vars context)))))
	   mu4e-contexts)))
   #+END_SRC

   smtpmail can take a very long time to send the mails, specially
   when there are large attachments. To prevent this lag use
   asynchronous functions. There are some issues with this, some users
   even report silent failures, so maybe you want to send your
   messages using another solution.
   #+BEGIN_SRC emacs-lisp :tangle yes
     ;; (require 'smtpmail-async)
     ;; (setq send-mail-function 'async-smtpmail-send-it
     ;;   message-send-mail-function 'async-smtpmail-send-it)
   #+END_SRC

